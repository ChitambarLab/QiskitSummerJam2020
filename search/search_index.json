{"config":{"lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"index.html","text":"Device-Independent Handshake Protocol \u00b6 A test suite to verify the quantum capabalities of unknown devices. Objective \u00b6 Our goal is to deliver a test suite which verifies quantum properties in bipartite communication scenarios. Our tests use measurement statistics to deduce properties such as hilbert space dimension, superpostion, measurement incompatibility, and entanglement. The test suite serves as piece of a broader handshake protocol required to establish trust of an unknown quantum devices. Our protocol is tested using Qiskit and the IBM quantum computers to simulate the bipartite quantum communication scenarios for which our handshake protocol is designed. Motivation \u00b6 The quantum internet will enable long-distance quantum cryptography, teleportation, and distributed quantum computation. Inevitably, long-distance quantum communications will require a large network of intermediary quantum-enabled devices [1]. As the size the size of quantum networks increases, a handshake protocol will be required to establish connections with unknown devices. It will be an important part of this handshake to determine whether a device can faithfully perform simple quantum communications tasks. Usage Guide \u00b6 Our codebase is found on github, https://github.com/ChitambarLab/QiskitSummerJam2020 . Please review the README.md for details regarding project use. About the Team \u00b6 We are an interdisciplinary group of PhD students working under Eric Chitambar in the Coordinated Science Lab at University of Illinois Urbana-Champaign. Members \u00b6 Chloe Kim Xinan Chen Louis Schatzki Brian Doolittle References \u00b6 [1] Wehner, Stephanie, David Elkouss, and Ronald Hanson. \"Quantum internet: A vision for the road ahead.\" Science 362.6412 (2018).","title":"Home"},{"location":"index.html#device-independent-handshake-protocol","text":"A test suite to verify the quantum capabalities of unknown devices.","title":"Device-Independent Handshake Protocol"},{"location":"index.html#objective","text":"Our goal is to deliver a test suite which verifies quantum properties in bipartite communication scenarios. Our tests use measurement statistics to deduce properties such as hilbert space dimension, superpostion, measurement incompatibility, and entanglement. The test suite serves as piece of a broader handshake protocol required to establish trust of an unknown quantum devices. Our protocol is tested using Qiskit and the IBM quantum computers to simulate the bipartite quantum communication scenarios for which our handshake protocol is designed.","title":"Objective"},{"location":"index.html#motivation","text":"The quantum internet will enable long-distance quantum cryptography, teleportation, and distributed quantum computation. Inevitably, long-distance quantum communications will require a large network of intermediary quantum-enabled devices [1]. As the size the size of quantum networks increases, a handshake protocol will be required to establish connections with unknown devices. It will be an important part of this handshake to determine whether a device can faithfully perform simple quantum communications tasks.","title":"Motivation"},{"location":"index.html#usage-guide","text":"Our codebase is found on github, https://github.com/ChitambarLab/QiskitSummerJam2020 . Please review the README.md for details regarding project use.","title":"Usage Guide"},{"location":"index.html#about-the-team","text":"We are an interdisciplinary group of PhD students working under Eric Chitambar in the Coordinated Science Lab at University of Illinois Urbana-Champaign.","title":"About the Team"},{"location":"index.html#members","text":"Chloe Kim Xinan Chen Louis Schatzki Brian Doolittle","title":"Members"},{"location":"index.html#references","text":"[1] Wehner, Stephanie, David Elkouss, and Ronald Hanson. \"Quantum internet: A vision for the road ahead.\" Science 362.6412 (2018).","title":"References"},{"location":"CHSH_theory.html","text":"CHSH Inequality as a Device-Independent Test of Entanglement \u00b6 Entanglement \u00b6 One of the most pecuiliar and perhaps also the most well-known quantum phenomena is quantum entanglement. Briefly summarized, entanglement gives rise to a non-classical correlation shared between two or more parties. To be more exact, a bipartite classical (separable) state is given as: \\rho^{AB} = \\sum_i p_i \\rho_i^A \\rho_i^B \\rho^{AB} = \\sum_i p_i \\rho_i^A \\rho_i^B whereas an entangled state is any \\rho^{AB} \\rho^{AB} that cannot be decomposed in the form above. An example of an entangled state is the Bell state |\\Phi^+\\rangle=\\frac{1}{\\sqrt{2}}|00\\rangle+\\frac{1}{\\sqrt{2}}|11\\rangle |\\Phi^+\\rangle=\\frac{1}{\\sqrt{2}}|00\\rangle+\\frac{1}{\\sqrt{2}}|11\\rangle . In his seminal paper in 1964, Bell showed that entangled states can demostrate fundamentally different correlations than correlations that are achievable with separable states. Later in 1969, Clauser, Horne, Shimony, and Holt modified the original approach set out by Bell, and gave a simpler inequality (now termed the CHSH inequality) that all separable states must satisfy. Curiously, there are entangled states that violates the CHSH inequality. We will discuss in more detail the CHSH inequality and its quantum violations below. The Classical Bound: CHSH Inequality \u00b6 Given any state \\rho^{AB} \\rho^{AB} that is shared between Alice and Bob, both parties can choose a measurement they would like to perform on their part of the state (here for simplicity we assume that they choose from two-outcome measurements labeled 1 and -1). Suppose that Alice chooses to measure X X , and Bob chooses to measure Y Y . After sufficient trials, we can calculate the expectation value \\langle XY\\rangle = P(XY=1)-P(XY=-1)=P(X=1,Y=1)+P(X=-1,Y=-1)-P(X=1,Y=-1)-P(X=-1,Y=1) \\langle XY\\rangle = P(XY=1)-P(XY=-1)=P(X=1,Y=1)+P(X=-1,Y=-1)-P(X=1,Y=-1)-P(X=-1,Y=1) . Now similarly, Alice and Bob can also change their measurement and measure X' X' and Y' Y' . If Alice and Bob share a separable state, then it must be that |\\langle XY\\rangle + \\langle X'Y\\rangle + \\langle XY'\\rangle - \\langle X'Y'\\rangle|\\le 2. |\\langle XY\\rangle + \\langle X'Y\\rangle + \\langle XY'\\rangle - \\langle X'Y'\\rangle|\\le 2. This is the CHSH inequality alluded to above. Quantum Violation of CHSH Inequality \u00b6 While all separable states must satisfy that |\\langle XY\\rangle + \\langle X'Y\\rangle + \\langle XY'\\rangle - \\langle X'Y'\\rangle|\\le 2 |\\langle XY\\rangle + \\langle X'Y\\rangle + \\langle XY'\\rangle - \\langle X'Y'\\rangle|\\le 2 , it is possible to violate this inequality with some entangled states. An example of such violation is achieved by the Bell state |\\Phi^+\\rangle=\\frac{1}{\\sqrt{2}}|00\\rangle+\\frac{1}{\\sqrt{2}}|11\\rangle |\\Phi^+\\rangle=\\frac{1}{\\sqrt{2}}|00\\rangle+\\frac{1}{\\sqrt{2}}|11\\rangle with measurements given by: X = \\sigma_x,\\quad X' = \\sigma_z,\\quad Y = \\frac{1}{\\sqrt{2}}(\\sigma_z+\\sigma_x),\\quad Y' = \\frac{1}{\\sqrt{2}}(\\sigma_z-\\sigma_x) X = \\sigma_x,\\quad X' = \\sigma_z,\\quad Y = \\frac{1}{\\sqrt{2}}(\\sigma_z+\\sigma_x),\\quad Y' = \\frac{1}{\\sqrt{2}}(\\sigma_z-\\sigma_x) where \\sigma_z \\sigma_z and \\sigma_x \\sigma_x are the Pauli Z and Pauli X operators respectively. Straightforward calculation reveals that the correlation will should be 2\\sqrt{2}>2 2\\sqrt{2}>2 in this case. Here, we will run the quantum computer to prepare |\\Phi^+\\rangle |\\Phi^+\\rangle and perform exactly this measurement to verify that we have indeed created an entangled state. Device Independence \u00b6 There are a number of ways to verify that a state is indeed entangled. The most straightforward approach is to perform a state tomography. The essential idea behind state tomography is to perform projective measurements onto an over-complete basis, and use the measurement statistics to reconstruct the original state. However, there is one caveat to this approach. We have to trust that the measurements being performed on the quantum system are indeed what we intended to perform. If the quantum system is \"secretly\" performing different measurements than what we thought, we could end up reconstructing an erroneous state, thus only have an illusion of entanglement. In contrast, verification of entanglement through violation of CHSH inequality is manifestly device-independent. All we need from the system and the measurement on the system is that they produce statistics that violates the CHSH inequality. As long as there is such a violation, then there has to be entanglment shared between the two parties (barring a couple of loopholes such as the locality loophole). References \u00b6","title":"Verifying Entanglement"},{"location":"CHSH_theory.html#chsh-inequality-as-a-device-independent-test-of-entanglement","text":"","title":"CHSH Inequality as a Device-Independent Test of Entanglement"},{"location":"CHSH_theory.html#entanglement","text":"One of the most pecuiliar and perhaps also the most well-known quantum phenomena is quantum entanglement. Briefly summarized, entanglement gives rise to a non-classical correlation shared between two or more parties. To be more exact, a bipartite classical (separable) state is given as: \\rho^{AB} = \\sum_i p_i \\rho_i^A \\rho_i^B \\rho^{AB} = \\sum_i p_i \\rho_i^A \\rho_i^B whereas an entangled state is any \\rho^{AB} \\rho^{AB} that cannot be decomposed in the form above. An example of an entangled state is the Bell state |\\Phi^+\\rangle=\\frac{1}{\\sqrt{2}}|00\\rangle+\\frac{1}{\\sqrt{2}}|11\\rangle |\\Phi^+\\rangle=\\frac{1}{\\sqrt{2}}|00\\rangle+\\frac{1}{\\sqrt{2}}|11\\rangle . In his seminal paper in 1964, Bell showed that entangled states can demostrate fundamentally different correlations than correlations that are achievable with separable states. Later in 1969, Clauser, Horne, Shimony, and Holt modified the original approach set out by Bell, and gave a simpler inequality (now termed the CHSH inequality) that all separable states must satisfy. Curiously, there are entangled states that violates the CHSH inequality. We will discuss in more detail the CHSH inequality and its quantum violations below.","title":"Entanglement"},{"location":"CHSH_theory.html#the-classical-bound-chsh-inequality","text":"Given any state \\rho^{AB} \\rho^{AB} that is shared between Alice and Bob, both parties can choose a measurement they would like to perform on their part of the state (here for simplicity we assume that they choose from two-outcome measurements labeled 1 and -1). Suppose that Alice chooses to measure X X , and Bob chooses to measure Y Y . After sufficient trials, we can calculate the expectation value \\langle XY\\rangle = P(XY=1)-P(XY=-1)=P(X=1,Y=1)+P(X=-1,Y=-1)-P(X=1,Y=-1)-P(X=-1,Y=1) \\langle XY\\rangle = P(XY=1)-P(XY=-1)=P(X=1,Y=1)+P(X=-1,Y=-1)-P(X=1,Y=-1)-P(X=-1,Y=1) . Now similarly, Alice and Bob can also change their measurement and measure X' X' and Y' Y' . If Alice and Bob share a separable state, then it must be that |\\langle XY\\rangle + \\langle X'Y\\rangle + \\langle XY'\\rangle - \\langle X'Y'\\rangle|\\le 2. |\\langle XY\\rangle + \\langle X'Y\\rangle + \\langle XY'\\rangle - \\langle X'Y'\\rangle|\\le 2. This is the CHSH inequality alluded to above.","title":"The Classical Bound: CHSH Inequality"},{"location":"CHSH_theory.html#quantum-violation-of-chsh-inequality","text":"While all separable states must satisfy that |\\langle XY\\rangle + \\langle X'Y\\rangle + \\langle XY'\\rangle - \\langle X'Y'\\rangle|\\le 2 |\\langle XY\\rangle + \\langle X'Y\\rangle + \\langle XY'\\rangle - \\langle X'Y'\\rangle|\\le 2 , it is possible to violate this inequality with some entangled states. An example of such violation is achieved by the Bell state |\\Phi^+\\rangle=\\frac{1}{\\sqrt{2}}|00\\rangle+\\frac{1}{\\sqrt{2}}|11\\rangle |\\Phi^+\\rangle=\\frac{1}{\\sqrt{2}}|00\\rangle+\\frac{1}{\\sqrt{2}}|11\\rangle with measurements given by: X = \\sigma_x,\\quad X' = \\sigma_z,\\quad Y = \\frac{1}{\\sqrt{2}}(\\sigma_z+\\sigma_x),\\quad Y' = \\frac{1}{\\sqrt{2}}(\\sigma_z-\\sigma_x) X = \\sigma_x,\\quad X' = \\sigma_z,\\quad Y = \\frac{1}{\\sqrt{2}}(\\sigma_z+\\sigma_x),\\quad Y' = \\frac{1}{\\sqrt{2}}(\\sigma_z-\\sigma_x) where \\sigma_z \\sigma_z and \\sigma_x \\sigma_x are the Pauli Z and Pauli X operators respectively. Straightforward calculation reveals that the correlation will should be 2\\sqrt{2}>2 2\\sqrt{2}>2 in this case. Here, we will run the quantum computer to prepare |\\Phi^+\\rangle |\\Phi^+\\rangle and perform exactly this measurement to verify that we have indeed created an entangled state.","title":"Quantum Violation of CHSH Inequality"},{"location":"CHSH_theory.html#device-independence","text":"There are a number of ways to verify that a state is indeed entangled. The most straightforward approach is to perform a state tomography. The essential idea behind state tomography is to perform projective measurements onto an over-complete basis, and use the measurement statistics to reconstruct the original state. However, there is one caveat to this approach. We have to trust that the measurements being performed on the quantum system are indeed what we intended to perform. If the quantum system is \"secretly\" performing different measurements than what we thought, we could end up reconstructing an erroneous state, thus only have an illusion of entanglement. In contrast, verification of entanglement through violation of CHSH inequality is manifestly device-independent. All we need from the system and the measurement on the system is that they produce statistics that violates the CHSH inequality. As long as there is such a violation, then there has to be entanglment shared between the two parties (barring a couple of loopholes such as the locality loophole).","title":"Device Independence"},{"location":"CHSH_theory.html#references","text":"","title":"References"},{"location":"Classical_Dimension_Test.html","text":"A Rudimentary Test for Classical Dimension \u00b6 Alice receives an input x\\in\\{0,1,2,3\\} x\\in\\{0,1,2,3\\} and sends it to Bob using 2 classical bits ( |0\\rangle |0\\rangle , |1\\rangle |1\\rangle qubits). Bob measures in the computational basis and outputs the result. The success probability for quantum and classical scenarios is bounded by d/N \\geq 1/N\\sum_x p(b=x,x) d/N \\geq 1/N\\sum_x p(b=x,x) , where d d is the number of dimensions in the hilbert space and N N is the number of inputs x x . The first test considers when Alice and Bob verify the ability to send two bits. The second test considers when Alice encodes the input onto a single bit. from qiskit import QuantumCircuit , execute , IBMQ from qiskit.tools.monitor import * from qiskit.providers.ibmq.managed import IBMQJobManager provider = IBMQ . load_account () import matplotlib.pyplot as plt import numpy as np import context from device_independent_test import dimension from device_independent_test.handshake import HandShake from device_independent_test.quantum_communicator import LocalDispatcher bit_circ = dimension . prepare_bit_circuit ([ 0 , 1 , 1 , 0 , 1 ]) bit_circ . draw () q_0: \u2500\u2500\u2500\u2500\u2500 \u250c\u2500\u2500\u2500\u2510 q_1: \u2524 X \u251c \u251c\u2500\u2500\u2500\u2524 q_2: \u2524 X \u251c \u2514\u2500\u2500\u2500\u2518 q_3: \u2500\u2500\u2500\u2500\u2500 \u250c\u2500\u2500\u2500\u2510 q_4: \u2524 X \u251c \u2514\u2500\u2500\u2500\u2518 Test 1) \u00b6 Alice and Bob can prepare and measure a set of orthogonal measurements on a 4-dimensional Hilbert space. Alice simply encodes the input x\\in\\{0,1,2,3\\} x\\in\\{0,1,2,3\\} into the bit string and Bob decodes it without error. Assuming a uniform prior distribution for x x , the success probability for this case is 1 \\geq 1/4 \\sum_x p(b=x|x) 1 \\geq 1/4 \\sum_x p(b=x|x) . # alice prepares the complete set of orthogonal states qc_00 = dimension . prepare_bit_circuit ([ 0 , 0 ]) qc_01 = dimension . prepare_bit_circuit ([ 0 , 1 ]) qc_10 = dimension . prepare_bit_circuit ([ 1 , 0 ]) qc_11 = dimension . prepare_bit_circuit ([ 1 , 1 ]) circuits = [ qc_00 , qc_01 , qc_10 , qc_11 ] # Bob measures in the computational basis. for qc in circuits : qc . measure_all () for qc in circuits : display ( qc . draw ()) \u2591 \u250c\u2500\u2510 q_0: \u2500\u2591\u2500\u2524M\u251c\u2500\u2500\u2500 \u2591 \u2514\u2565\u2518\u250c\u2500\u2510 q_1: \u2500\u2591\u2500\u2500\u256b\u2500\u2524M\u251c \u2591 \u2551 \u2514\u2565\u2518 meas_0: \u2550\u2550\u2550\u2550\u2569\u2550\u2550\u256c\u2550 \u2551 meas_1: \u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2569\u2550 \u2591 \u250c\u2500\u2510 q_0: \u2500\u2500\u2500\u2500\u2500\u2500\u2591\u2500\u2524M\u251c\u2500\u2500\u2500 \u250c\u2500\u2500\u2500\u2510 \u2591 \u2514\u2565\u2518\u250c\u2500\u2510 q_1: \u2524 X \u251c\u2500\u2591\u2500\u2500\u256b\u2500\u2524M\u251c \u2514\u2500\u2500\u2500\u2518 \u2591 \u2551 \u2514\u2565\u2518 meas_0: \u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2569\u2550\u2550\u256c\u2550 \u2551 meas_1: \u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2569\u2550 \u250c\u2500\u2500\u2500\u2510 \u2591 \u250c\u2500\u2510 q_0: \u2524 X \u251c\u2500\u2591\u2500\u2524M\u251c\u2500\u2500\u2500 \u2514\u2500\u2500\u2500\u2518 \u2591 \u2514\u2565\u2518\u250c\u2500\u2510 q_1: \u2500\u2500\u2500\u2500\u2500\u2500\u2591\u2500\u2500\u256b\u2500\u2524M\u251c \u2591 \u2551 \u2514\u2565\u2518 meas_0: \u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2569\u2550\u2550\u256c\u2550 \u2551 meas_1: \u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2569\u2550 \u250c\u2500\u2500\u2500\u2510 \u2591 \u250c\u2500\u2510 q_0: \u2524 X \u251c\u2500\u2591\u2500\u2524M\u251c\u2500\u2500\u2500 \u251c\u2500\u2500\u2500\u2524 \u2591 \u2514\u2565\u2518\u250c\u2500\u2510 q_1: \u2524 X \u251c\u2500\u2591\u2500\u2500\u256b\u2500\u2524M\u251c \u2514\u2500\u2500\u2500\u2518 \u2591 \u2551 \u2514\u2565\u2518 meas_0: \u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2569\u2550\u2550\u256c\u2550 \u2551 meas_1: \u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2569\u2550 # running tests on quantum computer def run_job ( qc , shots ): job = execute ( qc , backend = provider . get_backend ( 'ibmq_qasm_simulator' ), shots = shots ) job_monitor ( job ) return job shots = 1000 d4_job_00 = run_job ( qc_00 , shots ) d4_job_01 = run_job ( qc_01 , shots ) d4_job_10 = run_job ( qc_10 , shots ) d4_job_11 = run_job ( qc_11 , shots ) Job Status: job has successfully run Job Status: job has successfully run Job Status: job has successfully run Job Status: job has successfully run # parsing statistics d4_counts_00 = d4_job_00 . result () . get_counts () d4_counts_01 = d4_job_01 . result () . get_counts () d4_counts_10 = d4_job_10 . result () . get_counts () d4_counts_11 = d4_job_11 . result () . get_counts () # success probability for a d=4 system is 1 p_succ_00 = d4_counts_00 [ \"00\" ] / shots p_succ_01 = d4_counts_01 [ \"10\" ] / shots # qiskits labeling is weird p_succ_10 = d4_counts_10 [ \"01\" ] / shots # qiskits labeling is weird p_succ_11 = d4_counts_11 [ \"11\" ] / shots d4_success_probability = ( p_succ_00 + p_succ_01 + p_succ_10 + p_succ_11 ) / 4 # divide by 4 because there are 4 inputs. d4_success_probability 1.0 Above test can be run as the following with specific tolerance and shots. dispatcher = LocalDispatcher ([ provider . get_backend ( 'ibmq_qasm_simulator' )]) handshake = HandShake ( dispatcher ) tolerance = 0.1 shots = 1000 handshake . dimensionality ( tolerance , shots ) Passed Dimensionality with value: 1.0 (True, 1.0) dispatcher = LocalDispatcher ([ provider . get_backend ( 'ibmq_london' )]) handshake = HandShake ( dispatcher ) tolerance = 0.1 shots = 1000 handshake . dimensionality ( tolerance , shots ) Passed Dimensionality with value: 0.9065 (True, 0.9065) Test 2) \u00b6 Alice can only encode information in one classical bit, the second bit is constant. The measurement success_probability is 0.5 \\geq 1/4 \\sum_x p(b=x|x) 0.5 \\geq 1/4 \\sum_x p(b=x|x) . shots = 1000 d2_job_00 = run_job ( qc_00 , shots ) d2_job_01 = run_job ( qc_00 , shots ) d2_job_10 = run_job ( qc_10 , shots ) d2_job_11 = run_job ( qc_10 , shots ) counts_00 = d2_job_00 . result () . get_counts () counts_01 = d2_job_01 . result () . get_counts () counts_10 = d2_job_10 . result () . get_counts () counts_11 = d2_job_11 . result () . get_counts () d2_p_succ_00 = counts_00 [ \"00\" ] / shots if ( \"00\" in counts_00 ) else 0.0 d2_p_succ_01 = counts_01 [ \"10\" ] / shots if ( \"10\" in counts_01 ) else 0.0 # qiskits labeling is weird d2_p_succ_10 = counts_10 [ \"01\" ] / shots if \"01\" in counts_10 else 0.0 # qiskits labeling is weird d2_p_succ_11 = counts_11 [ \"11\" ] / shots if \"11\" in counts_11 else 0.0 d2_success_probability = ( d2_p_succ_00 + d2_p_succ_01 + d2_p_succ_10 + d2_p_succ_11 ) / 2 d2_success_probability # the classical bound is 0.5","title":"Classical Dimension Test"},{"location":"Classical_Dimension_Test.html#a-rudimentary-test-for-classical-dimension","text":"Alice receives an input x\\in\\{0,1,2,3\\} x\\in\\{0,1,2,3\\} and sends it to Bob using 2 classical bits ( |0\\rangle |0\\rangle , |1\\rangle |1\\rangle qubits). Bob measures in the computational basis and outputs the result. The success probability for quantum and classical scenarios is bounded by d/N \\geq 1/N\\sum_x p(b=x,x) d/N \\geq 1/N\\sum_x p(b=x,x) , where d d is the number of dimensions in the hilbert space and N N is the number of inputs x x . The first test considers when Alice and Bob verify the ability to send two bits. The second test considers when Alice encodes the input onto a single bit. from qiskit import QuantumCircuit , execute , IBMQ from qiskit.tools.monitor import * from qiskit.providers.ibmq.managed import IBMQJobManager provider = IBMQ . load_account () import matplotlib.pyplot as plt import numpy as np import context from device_independent_test import dimension from device_independent_test.handshake import HandShake from device_independent_test.quantum_communicator import LocalDispatcher bit_circ = dimension . prepare_bit_circuit ([ 0 , 1 , 1 , 0 , 1 ]) bit_circ . draw () q_0: \u2500\u2500\u2500\u2500\u2500 \u250c\u2500\u2500\u2500\u2510 q_1: \u2524 X \u251c \u251c\u2500\u2500\u2500\u2524 q_2: \u2524 X \u251c \u2514\u2500\u2500\u2500\u2518 q_3: \u2500\u2500\u2500\u2500\u2500 \u250c\u2500\u2500\u2500\u2510 q_4: \u2524 X \u251c \u2514\u2500\u2500\u2500\u2518","title":"A Rudimentary Test for Classical Dimension"},{"location":"Classical_Dimension_Test.html#test-1","text":"Alice and Bob can prepare and measure a set of orthogonal measurements on a 4-dimensional Hilbert space. Alice simply encodes the input x\\in\\{0,1,2,3\\} x\\in\\{0,1,2,3\\} into the bit string and Bob decodes it without error. Assuming a uniform prior distribution for x x , the success probability for this case is 1 \\geq 1/4 \\sum_x p(b=x|x) 1 \\geq 1/4 \\sum_x p(b=x|x) . # alice prepares the complete set of orthogonal states qc_00 = dimension . prepare_bit_circuit ([ 0 , 0 ]) qc_01 = dimension . prepare_bit_circuit ([ 0 , 1 ]) qc_10 = dimension . prepare_bit_circuit ([ 1 , 0 ]) qc_11 = dimension . prepare_bit_circuit ([ 1 , 1 ]) circuits = [ qc_00 , qc_01 , qc_10 , qc_11 ] # Bob measures in the computational basis. for qc in circuits : qc . measure_all () for qc in circuits : display ( qc . draw ()) \u2591 \u250c\u2500\u2510 q_0: \u2500\u2591\u2500\u2524M\u251c\u2500\u2500\u2500 \u2591 \u2514\u2565\u2518\u250c\u2500\u2510 q_1: \u2500\u2591\u2500\u2500\u256b\u2500\u2524M\u251c \u2591 \u2551 \u2514\u2565\u2518 meas_0: \u2550\u2550\u2550\u2550\u2569\u2550\u2550\u256c\u2550 \u2551 meas_1: \u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2569\u2550 \u2591 \u250c\u2500\u2510 q_0: \u2500\u2500\u2500\u2500\u2500\u2500\u2591\u2500\u2524M\u251c\u2500\u2500\u2500 \u250c\u2500\u2500\u2500\u2510 \u2591 \u2514\u2565\u2518\u250c\u2500\u2510 q_1: \u2524 X \u251c\u2500\u2591\u2500\u2500\u256b\u2500\u2524M\u251c \u2514\u2500\u2500\u2500\u2518 \u2591 \u2551 \u2514\u2565\u2518 meas_0: \u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2569\u2550\u2550\u256c\u2550 \u2551 meas_1: \u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2569\u2550 \u250c\u2500\u2500\u2500\u2510 \u2591 \u250c\u2500\u2510 q_0: \u2524 X \u251c\u2500\u2591\u2500\u2524M\u251c\u2500\u2500\u2500 \u2514\u2500\u2500\u2500\u2518 \u2591 \u2514\u2565\u2518\u250c\u2500\u2510 q_1: \u2500\u2500\u2500\u2500\u2500\u2500\u2591\u2500\u2500\u256b\u2500\u2524M\u251c \u2591 \u2551 \u2514\u2565\u2518 meas_0: \u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2569\u2550\u2550\u256c\u2550 \u2551 meas_1: \u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2569\u2550 \u250c\u2500\u2500\u2500\u2510 \u2591 \u250c\u2500\u2510 q_0: \u2524 X \u251c\u2500\u2591\u2500\u2524M\u251c\u2500\u2500\u2500 \u251c\u2500\u2500\u2500\u2524 \u2591 \u2514\u2565\u2518\u250c\u2500\u2510 q_1: \u2524 X \u251c\u2500\u2591\u2500\u2500\u256b\u2500\u2524M\u251c \u2514\u2500\u2500\u2500\u2518 \u2591 \u2551 \u2514\u2565\u2518 meas_0: \u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2569\u2550\u2550\u256c\u2550 \u2551 meas_1: \u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2569\u2550 # running tests on quantum computer def run_job ( qc , shots ): job = execute ( qc , backend = provider . get_backend ( 'ibmq_qasm_simulator' ), shots = shots ) job_monitor ( job ) return job shots = 1000 d4_job_00 = run_job ( qc_00 , shots ) d4_job_01 = run_job ( qc_01 , shots ) d4_job_10 = run_job ( qc_10 , shots ) d4_job_11 = run_job ( qc_11 , shots ) Job Status: job has successfully run Job Status: job has successfully run Job Status: job has successfully run Job Status: job has successfully run # parsing statistics d4_counts_00 = d4_job_00 . result () . get_counts () d4_counts_01 = d4_job_01 . result () . get_counts () d4_counts_10 = d4_job_10 . result () . get_counts () d4_counts_11 = d4_job_11 . result () . get_counts () # success probability for a d=4 system is 1 p_succ_00 = d4_counts_00 [ \"00\" ] / shots p_succ_01 = d4_counts_01 [ \"10\" ] / shots # qiskits labeling is weird p_succ_10 = d4_counts_10 [ \"01\" ] / shots # qiskits labeling is weird p_succ_11 = d4_counts_11 [ \"11\" ] / shots d4_success_probability = ( p_succ_00 + p_succ_01 + p_succ_10 + p_succ_11 ) / 4 # divide by 4 because there are 4 inputs. d4_success_probability 1.0 Above test can be run as the following with specific tolerance and shots. dispatcher = LocalDispatcher ([ provider . get_backend ( 'ibmq_qasm_simulator' )]) handshake = HandShake ( dispatcher ) tolerance = 0.1 shots = 1000 handshake . dimensionality ( tolerance , shots ) Passed Dimensionality with value: 1.0 (True, 1.0) dispatcher = LocalDispatcher ([ provider . get_backend ( 'ibmq_london' )]) handshake = HandShake ( dispatcher ) tolerance = 0.1 shots = 1000 handshake . dimensionality ( tolerance , shots ) Passed Dimensionality with value: 0.9065 (True, 0.9065)","title":"Test 1)"},{"location":"Classical_Dimension_Test.html#test-2","text":"Alice can only encode information in one classical bit, the second bit is constant. The measurement success_probability is 0.5 \\geq 1/4 \\sum_x p(b=x|x) 0.5 \\geq 1/4 \\sum_x p(b=x|x) . shots = 1000 d2_job_00 = run_job ( qc_00 , shots ) d2_job_01 = run_job ( qc_00 , shots ) d2_job_10 = run_job ( qc_10 , shots ) d2_job_11 = run_job ( qc_10 , shots ) counts_00 = d2_job_00 . result () . get_counts () counts_01 = d2_job_01 . result () . get_counts () counts_10 = d2_job_10 . result () . get_counts () counts_11 = d2_job_11 . result () . get_counts () d2_p_succ_00 = counts_00 [ \"00\" ] / shots if ( \"00\" in counts_00 ) else 0.0 d2_p_succ_01 = counts_01 [ \"10\" ] / shots if ( \"10\" in counts_01 ) else 0.0 # qiskits labeling is weird d2_p_succ_10 = counts_10 [ \"01\" ] / shots if \"01\" in counts_10 else 0.0 # qiskits labeling is weird d2_p_succ_11 = counts_11 [ \"11\" ] / shots if \"11\" in counts_11 else 0.0 d2_success_probability = ( d2_p_succ_00 + d2_p_succ_01 + d2_p_succ_10 + d2_p_succ_11 ) / 2 d2_success_probability # the classical bound is 0.5","title":"Test 2)"},{"location":"Device_Independent_Test_Documentation.html","text":"Device Independent Test Documentation \u00b6 Below is a draft of an introduction. Device Independent Test is a python library which runs tests on quantum systems through IBM's Qiskit. The motivation for this library is the following scenario: there are two quantum computers (say, Alice's and Bob's) with some sort of network connecting them. We trust Alice's computer to be a functional quantum device. However, we do not yet trust Bob's computer. We wish to transmit states from Alice's computer to Bob's, and ask Bob to run certain operations to ascertain the functionality of our transmission and his system. There are [NUMBER] tests in this library: dimensionality, incompatible measurements, and entanglement. This library includes the following modules: dimension, incompatible_measurement, and entanglement. In addition, there are two classes: handshake and QuantumDispatcher. The documentation below goes over each of these files in detail. Classes \u00b6 HandShake \u00b6 Interface between the user and the test modules. Initialized with an instance of QuantumDispatcher. You can use this object to run and store the results of tests. Methods Descriptions __init__(QuantumDispatcher) Constructor storing a QuantumDispatcher instance to run tests with. dimensionality(tolerance, shots) Runs the dimensionality test with specified tolerance (float) and number of shots (int). measurement_incompatibility(tolerance, shots) Runs the incompatible measurement test with specified tolerance and shots. Returns a tuple with the pass/fail and the value of the bell violation. entanglement(tolerance, shots) Runs the entanglement test with specified tolerance and number of shots. test('name',tolerance, shots) Runs the test specified by 'name'. Prints available tests if 'name' does not exit. print_tests() Prints the available tests. write_to('file') Writs accumulated data to file. Below is an example of using a handshake object to run an incompatible measurment test. provider = IBMQ . load_account () dispatch = quantum_communicator . LocalDispatcher ([ provider . get_backend ( 'ibmq_qasm_simulator' )]) test = incompatible_measurement . run_test ( dispatch , 0.0 , 1000 ) Quantum_Dispatcher \u00b6 An abstract base class to generalize the dispatching and running of operations across a system. Offers an interface from which future classes that work with a quantum network can run the tests. Methods Descriptions init (backends) Constructor requiring a list of backends. Abstract Methods Description run_and_transmit(input_registers,output_registers,pre_operations,post_operations,shot) Dispatches a single job to the quantum system. The circuit specified in pre_operations is ran on the device responsible for preparing states. The states from input_registers are then sent to the output_registers. Next, the operations in the list post_operations are executed. The index of the operation in this array corresponds to which device it runs on. Returns a dictionary with the counts from measurements on the system. multi_run_and_transmit(input_registers,output_register,pre_operations,post_operations,shot) Dispatches multiple jobs to the quantum system. Pre_operations is a list of circuits. Post_operations is a list of lists, representing operations to run on different machines. Returns a list of dictionaries with the counts from measurements on the system. batch_run_and_transmit(input_registers,output_registers,pre_operations,post_operations,shot) Distpatches and runs all permuations of the given operations. Returns a list of dictionaries with the counts from measurements on the system. LocalDispatcher \u00b6 Implements the Quantum_Dispatcher interface for running tests on a single computer. Note that the input and output register parameters are not used by this class. Methods Descriptions init (backends) Only the first element in the list backends is used. run_and_transmit(input_registers,output_registers,pre_operations,post_operations,shot) See QuantumDispatcher. Does not use the registers. Returns counts from running the circuits. multi_run_and_transmit(input_registers,output_register,pre_operations,post_operations,shot) See QuantumDispatcher. Does not use the registers. Returns a list of counts from running the circuits. batch_run_and_transmit(input_registers,output_registers,pre_operations,post_operations,shot) See QuantumDispatcher. Does not use the registers. Returns a list of counts from running all permutations of the circuits. Below is an example of creating an instance of LocalDispatcher. provider = IBMQ . load_account () dispatch = quantum_communicator . LocalDispatcher ([ provider . get_backend ( 'ibmq_qasm_simulator' )]) Modules \u00b6 Dimension \u00b6 Incompatible_Measurement \u00b6 A module to conduct tests of Bell violations from incompatible measurements. Methods Descriptions run_test(dispatcher,tolerance,shots) Sends a incompatible measurement test to run on dispatcher. bb84_states() Returns a circuit that creates the 0, 1, +, and - states on 4 registers. measure_circuit(y) Returns Bob's circuit measuring 4 registers in the pi/8 (y=0) or 3*pi/8 (y=1) rotated basis. bell_violation(y0_counts,y1_counts,y0_shots,y1_shots) Returns the value of the test minus the classical value. bell_score(y0_probs,y1_probs) Returns the value of the test from the conditional probability distribution. conditional_probs(counts,shots) Parses the counts from a job and returns a 2x4 matrix of conditional probabilities. Entanglement \u00b6 Example Code \u00b6 Incompatible Measurement Example \u00b6 # Importing standard Qiskit libraries and configuring account from qiskit import QuantumCircuit , execute , Aer , IBMQ from qiskit.compiler import transpile , assemble from qiskit.tools.jupyter import * from qiskit.visualization import * from qiskit.providers.ibmq.managed import IBMQJobManager # Loading your IBM Q account(s) import qiskit from qiskit import IBMQ provider = IBMQ . load_account () import numpy as np import context from device_independent_test import handshake from device_independent_test import quantum_communicator from device_independent_test import entanglement ibmqfactory.load_account:WARNING:2020-06-29 23:49:59,350: Credentials are already in use. The existing account in the session will be replaced. Below is an incompatibility test that should output a violation. communicator = quantum_communicator . LocalDispatcher ([ provider . get_backend ( 'ibmq_qasm_simulator' )]) obj = handshake . HandShake ( communicator ) obj . measurement_incompatibility ( 0.0 , 5000 , 0 ) #obj.entanglement(0.0,5000) #entanglement.run_test_parallel(communicator,0.0,1000) \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\u250c\u2500\u2510 q_0: \u2524 circuit13 \u251c\u2524M\u251c \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\u2514\u2565\u2518 c_0: \u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2569\u2550 \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\u250c\u2500\u2510 q_0: \u2524 circuit68 \u251c\u2524M\u251c \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\u2514\u2565\u2518 c_0: \u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2569\u2550 \u250c\u2500\u2500\u2500\u2510\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\u250c\u2500\u2510 q_0: \u2524 X \u251c\u2524 circuit13 \u251c\u2524M\u251c \u2514\u2500\u2500\u2500\u2518\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\u2514\u2565\u2518 c_0: \u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2569\u2550 \u250c\u2500\u2500\u2500\u2510\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\u250c\u2500\u2510 q_0: \u2524 X \u251c\u2524 circuit68 \u251c\u2524M\u251c \u2514\u2500\u2500\u2500\u2518\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\u2514\u2565\u2518 c_0: \u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2569\u2550 \u250c\u2500\u2500\u2500\u2510\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\u250c\u2500\u2510 q_0: \u2524 H \u251c\u2524 circuit13 \u251c\u2524M\u251c \u2514\u2500\u2500\u2500\u2518\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\u2514\u2565\u2518 c_0: \u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2569\u2550 \u250c\u2500\u2500\u2500\u2510\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\u250c\u2500\u2510 q_0: \u2524 H \u251c\u2524 circuit68 \u251c\u2524M\u251c \u2514\u2500\u2500\u2500\u2518\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\u2514\u2565\u2518 c_0: \u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2569\u2550 \u250c\u2500\u2500\u2500\u2510\u250c\u2500\u2500\u2500\u2510\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\u250c\u2500\u2510 q_0: \u2524 X \u251c\u2524 H \u251c\u2524 circuit13 \u251c\u2524M\u251c \u2514\u2500\u2500\u2500\u2518\u2514\u2500\u2500\u2500\u2518\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\u2514\u2565\u2518 c_0: \u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2569\u2550 \u250c\u2500\u2500\u2500\u2510\u250c\u2500\u2500\u2500\u2510\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\u250c\u2500\u2510 q_0: \u2524 X \u251c\u2524 H \u251c\u2524 circuit68 \u251c\u2524M\u251c \u2514\u2500\u2500\u2500\u2518\u2514\u2500\u2500\u2500\u2518\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\u2514\u2565\u2518 c_0: \u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2569\u2550 Failed Measurment Incompatibility with value: 6.8334 (False, 6.8334) test = \"1101\" print ( test [ 0 : 2 ]) 11 test = QuantumCircuit ( 2 , 2 ) test . x ( 0 ) test . measure ( 0 , 0 ) test . draw () \u250c\u2500\u2500\u2500\u2510\u250c\u2500\u2510 q_0: \u2524 X \u251c\u2524M\u251c \u2514\u2500\u2500\u2500\u2518\u2514\u2565\u2518 q_1: \u2500\u2500\u2500\u2500\u2500\u2500\u256b\u2500 \u2551 c_0: \u2550\u2550\u2550\u2550\u2550\u2550\u2569\u2550 c_1: \u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550 Below is a hard coded example of the incompatibility test failing when Bob does not do the correct operations. from device_independent_test import incompatible_measurement dispatch = quantum_communicator . LocalDispatcher ([ provider . get_backend ( 'ibmq_qasm_simulator' )]) # create bb84 states pre_ops = [ incompatible_measurement . bb84_states ()] # measure in the wrong basis qc0 = QuantumCircuit ( 4 ) qc0 . u3 ( - np . pi , 0 , 0 , range ( 0 , 4 )) qc0 . measure_all () qc1 = QuantumCircuit ( 4 ) qc1 . u3 ( 0 , 0 , 0 , range ( 0 , 4 )) qc1 . measure_all () post_ops = [[ QuantumCircuit ( 4 )],[ qc0 , qc1 ]] counts = dispatch . batch_run_and_transmit ( pre_ops , post_ops , 1000 ) violation = incompatible_measurement . bell_violation ( counts [ 0 ], counts [ 1 ], 1000 , 1000 ) print ( violation ) 1.9869999999999999","title":"device_independent_test Module"},{"location":"Device_Independent_Test_Documentation.html#device-independent-test-documentation","text":"Below is a draft of an introduction. Device Independent Test is a python library which runs tests on quantum systems through IBM's Qiskit. The motivation for this library is the following scenario: there are two quantum computers (say, Alice's and Bob's) with some sort of network connecting them. We trust Alice's computer to be a functional quantum device. However, we do not yet trust Bob's computer. We wish to transmit states from Alice's computer to Bob's, and ask Bob to run certain operations to ascertain the functionality of our transmission and his system. There are [NUMBER] tests in this library: dimensionality, incompatible measurements, and entanglement. This library includes the following modules: dimension, incompatible_measurement, and entanglement. In addition, there are two classes: handshake and QuantumDispatcher. The documentation below goes over each of these files in detail.","title":"Device Independent Test Documentation"},{"location":"Device_Independent_Test_Documentation.html#classes","text":"","title":"Classes"},{"location":"Device_Independent_Test_Documentation.html#handshake","text":"Interface between the user and the test modules. Initialized with an instance of QuantumDispatcher. You can use this object to run and store the results of tests. Methods Descriptions __init__(QuantumDispatcher) Constructor storing a QuantumDispatcher instance to run tests with. dimensionality(tolerance, shots) Runs the dimensionality test with specified tolerance (float) and number of shots (int). measurement_incompatibility(tolerance, shots) Runs the incompatible measurement test with specified tolerance and shots. Returns a tuple with the pass/fail and the value of the bell violation. entanglement(tolerance, shots) Runs the entanglement test with specified tolerance and number of shots. test('name',tolerance, shots) Runs the test specified by 'name'. Prints available tests if 'name' does not exit. print_tests() Prints the available tests. write_to('file') Writs accumulated data to file. Below is an example of using a handshake object to run an incompatible measurment test. provider = IBMQ . load_account () dispatch = quantum_communicator . LocalDispatcher ([ provider . get_backend ( 'ibmq_qasm_simulator' )]) test = incompatible_measurement . run_test ( dispatch , 0.0 , 1000 )","title":"HandShake"},{"location":"Device_Independent_Test_Documentation.html#quantum_dispatcher","text":"An abstract base class to generalize the dispatching and running of operations across a system. Offers an interface from which future classes that work with a quantum network can run the tests. Methods Descriptions init (backends) Constructor requiring a list of backends. Abstract Methods Description run_and_transmit(input_registers,output_registers,pre_operations,post_operations,shot) Dispatches a single job to the quantum system. The circuit specified in pre_operations is ran on the device responsible for preparing states. The states from input_registers are then sent to the output_registers. Next, the operations in the list post_operations are executed. The index of the operation in this array corresponds to which device it runs on. Returns a dictionary with the counts from measurements on the system. multi_run_and_transmit(input_registers,output_register,pre_operations,post_operations,shot) Dispatches multiple jobs to the quantum system. Pre_operations is a list of circuits. Post_operations is a list of lists, representing operations to run on different machines. Returns a list of dictionaries with the counts from measurements on the system. batch_run_and_transmit(input_registers,output_registers,pre_operations,post_operations,shot) Distpatches and runs all permuations of the given operations. Returns a list of dictionaries with the counts from measurements on the system.","title":"Quantum_Dispatcher"},{"location":"Device_Independent_Test_Documentation.html#localdispatcher","text":"Implements the Quantum_Dispatcher interface for running tests on a single computer. Note that the input and output register parameters are not used by this class. Methods Descriptions init (backends) Only the first element in the list backends is used. run_and_transmit(input_registers,output_registers,pre_operations,post_operations,shot) See QuantumDispatcher. Does not use the registers. Returns counts from running the circuits. multi_run_and_transmit(input_registers,output_register,pre_operations,post_operations,shot) See QuantumDispatcher. Does not use the registers. Returns a list of counts from running the circuits. batch_run_and_transmit(input_registers,output_registers,pre_operations,post_operations,shot) See QuantumDispatcher. Does not use the registers. Returns a list of counts from running all permutations of the circuits. Below is an example of creating an instance of LocalDispatcher. provider = IBMQ . load_account () dispatch = quantum_communicator . LocalDispatcher ([ provider . get_backend ( 'ibmq_qasm_simulator' )])","title":"LocalDispatcher"},{"location":"Device_Independent_Test_Documentation.html#modules","text":"","title":"Modules"},{"location":"Device_Independent_Test_Documentation.html#dimension","text":"","title":"Dimension"},{"location":"Device_Independent_Test_Documentation.html#incompatible_measurement","text":"A module to conduct tests of Bell violations from incompatible measurements. Methods Descriptions run_test(dispatcher,tolerance,shots) Sends a incompatible measurement test to run on dispatcher. bb84_states() Returns a circuit that creates the 0, 1, +, and - states on 4 registers. measure_circuit(y) Returns Bob's circuit measuring 4 registers in the pi/8 (y=0) or 3*pi/8 (y=1) rotated basis. bell_violation(y0_counts,y1_counts,y0_shots,y1_shots) Returns the value of the test minus the classical value. bell_score(y0_probs,y1_probs) Returns the value of the test from the conditional probability distribution. conditional_probs(counts,shots) Parses the counts from a job and returns a 2x4 matrix of conditional probabilities.","title":"Incompatible_Measurement"},{"location":"Device_Independent_Test_Documentation.html#entanglement","text":"","title":"Entanglement"},{"location":"Device_Independent_Test_Documentation.html#example-code","text":"","title":"Example Code"},{"location":"Device_Independent_Test_Documentation.html#incompatible-measurement-example","text":"# Importing standard Qiskit libraries and configuring account from qiskit import QuantumCircuit , execute , Aer , IBMQ from qiskit.compiler import transpile , assemble from qiskit.tools.jupyter import * from qiskit.visualization import * from qiskit.providers.ibmq.managed import IBMQJobManager # Loading your IBM Q account(s) import qiskit from qiskit import IBMQ provider = IBMQ . load_account () import numpy as np import context from device_independent_test import handshake from device_independent_test import quantum_communicator from device_independent_test import entanglement ibmqfactory.load_account:WARNING:2020-06-29 23:49:59,350: Credentials are already in use. The existing account in the session will be replaced. Below is an incompatibility test that should output a violation. communicator = quantum_communicator . LocalDispatcher ([ provider . get_backend ( 'ibmq_qasm_simulator' )]) obj = handshake . HandShake ( communicator ) obj . measurement_incompatibility ( 0.0 , 5000 , 0 ) #obj.entanglement(0.0,5000) #entanglement.run_test_parallel(communicator,0.0,1000) \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\u250c\u2500\u2510 q_0: \u2524 circuit13 \u251c\u2524M\u251c \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\u2514\u2565\u2518 c_0: \u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2569\u2550 \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\u250c\u2500\u2510 q_0: \u2524 circuit68 \u251c\u2524M\u251c \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\u2514\u2565\u2518 c_0: \u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2569\u2550 \u250c\u2500\u2500\u2500\u2510\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\u250c\u2500\u2510 q_0: \u2524 X \u251c\u2524 circuit13 \u251c\u2524M\u251c \u2514\u2500\u2500\u2500\u2518\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\u2514\u2565\u2518 c_0: \u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2569\u2550 \u250c\u2500\u2500\u2500\u2510\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\u250c\u2500\u2510 q_0: \u2524 X \u251c\u2524 circuit68 \u251c\u2524M\u251c \u2514\u2500\u2500\u2500\u2518\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\u2514\u2565\u2518 c_0: \u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2569\u2550 \u250c\u2500\u2500\u2500\u2510\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\u250c\u2500\u2510 q_0: \u2524 H \u251c\u2524 circuit13 \u251c\u2524M\u251c \u2514\u2500\u2500\u2500\u2518\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\u2514\u2565\u2518 c_0: \u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2569\u2550 \u250c\u2500\u2500\u2500\u2510\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\u250c\u2500\u2510 q_0: \u2524 H \u251c\u2524 circuit68 \u251c\u2524M\u251c \u2514\u2500\u2500\u2500\u2518\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\u2514\u2565\u2518 c_0: \u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2569\u2550 \u250c\u2500\u2500\u2500\u2510\u250c\u2500\u2500\u2500\u2510\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\u250c\u2500\u2510 q_0: \u2524 X \u251c\u2524 H \u251c\u2524 circuit13 \u251c\u2524M\u251c \u2514\u2500\u2500\u2500\u2518\u2514\u2500\u2500\u2500\u2518\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\u2514\u2565\u2518 c_0: \u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2569\u2550 \u250c\u2500\u2500\u2500\u2510\u250c\u2500\u2500\u2500\u2510\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\u250c\u2500\u2510 q_0: \u2524 X \u251c\u2524 H \u251c\u2524 circuit68 \u251c\u2524M\u251c \u2514\u2500\u2500\u2500\u2518\u2514\u2500\u2500\u2500\u2518\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\u2514\u2565\u2518 c_0: \u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2569\u2550 Failed Measurment Incompatibility with value: 6.8334 (False, 6.8334) test = \"1101\" print ( test [ 0 : 2 ]) 11 test = QuantumCircuit ( 2 , 2 ) test . x ( 0 ) test . measure ( 0 , 0 ) test . draw () \u250c\u2500\u2500\u2500\u2510\u250c\u2500\u2510 q_0: \u2524 X \u251c\u2524M\u251c \u2514\u2500\u2500\u2500\u2518\u2514\u2565\u2518 q_1: \u2500\u2500\u2500\u2500\u2500\u2500\u256b\u2500 \u2551 c_0: \u2550\u2550\u2550\u2550\u2550\u2550\u2569\u2550 c_1: \u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550 Below is a hard coded example of the incompatibility test failing when Bob does not do the correct operations. from device_independent_test import incompatible_measurement dispatch = quantum_communicator . LocalDispatcher ([ provider . get_backend ( 'ibmq_qasm_simulator' )]) # create bb84 states pre_ops = [ incompatible_measurement . bb84_states ()] # measure in the wrong basis qc0 = QuantumCircuit ( 4 ) qc0 . u3 ( - np . pi , 0 , 0 , range ( 0 , 4 )) qc0 . measure_all () qc1 = QuantumCircuit ( 4 ) qc1 . u3 ( 0 , 0 , 0 , range ( 0 , 4 )) qc1 . measure_all () post_ops = [[ QuantumCircuit ( 4 )],[ qc0 , qc1 ]] counts = dispatch . batch_run_and_transmit ( pre_ops , post_ops , 1000 ) violation = incompatible_measurement . bell_violation ( counts [ 0 ], counts [ 1 ], 1000 , 1000 ) print ( violation ) 1.9869999999999999","title":"Incompatible Measurement Example"},{"location":"Entanglement.html","text":"Entanglement Testing \u00b6 # Importing standard Qiskit libraries and configuring account from qiskit import QuantumCircuit , execute , Aer , IBMQ from qiskit.compiler import transpile , assemble from qiskit.tools.jupyter import * from qiskit.visualization import * from qiskit.providers.ibmq.managed import IBMQJobManager # Loading your IBM Q account(s) import qiskit from qiskit import IBMQ import matplotlib.pyplot as plt import numpy as np from device_independent_test.entanglement import EntanglementTest test = EntanglementTest () test . run_CHSH_test ( backend = \"ibmq_qasm_simulator\" , shots = 3000 ) ibmqfactory.load_account:WARNING:2020-06-26 16:49:59,854: Credentials are already in use. The existing account in the session will be replaced. {'received': 2.844, 'expected': 2.8284271247461903}","title":"Entanglement Test"},{"location":"Entanglement.html#entanglement-testing","text":"# Importing standard Qiskit libraries and configuring account from qiskit import QuantumCircuit , execute , Aer , IBMQ from qiskit.compiler import transpile , assemble from qiskit.tools.jupyter import * from qiskit.visualization import * from qiskit.providers.ibmq.managed import IBMQJobManager # Loading your IBM Q account(s) import qiskit from qiskit import IBMQ import matplotlib.pyplot as plt import numpy as np from device_independent_test.entanglement import EntanglementTest test = EntanglementTest () test . run_CHSH_test ( backend = \"ibmq_qasm_simulator\" , shots = 3000 ) ibmqfactory.load_account:WARNING:2020-06-26 16:49:59,854: Credentials are already in use. The existing account in the session will be replaced. {'received': 2.844, 'expected': 2.8284271247461903}","title":"Entanglement Testing"},{"location":"Incompatible_Measurement.html","text":"Measurement Incompatibility Testing \u00b6 # Make sure to load your IBM Q token before running the below block # Importing standard Qiskit libraries and configuring account from qiskit import QuantumCircuit , execute , IBMQ from qiskit.tools.jupyter import * from qiskit.visualization import * from qiskit.providers.ibmq.managed import IBMQJobManager # Loading your IBM Q account(s) provider = IBMQ . load_account () import matplotlib.pyplot as plt import numpy as np # custom code import context from device_independent_test import incompatible_measurement from device_independent_test import quantum_communicator def bb84_states (): # Alice's half of the circuit # creates 0,1,+,- qc = QuantumCircuit ( 4 ) qc . x ( 1 ) # create 1 qc . h ( 2 ) # create + qc . x ( 3 ) # create - qc . h ( 3 ) # ^ return qc def measure_circuit ( y ): # Bob's measurement circuit # measure in either pi/4 or 3pi/4 basis assert y == 0 or y == 1 , \"Bob's input should be 0 or 1\" qc = QuantumCircuit ( 4 ) theta = - 1.0 * ( np . pi / 4 + 0.5 * y * np . pi ) qc . u3 ( theta , 0 , 0 , range ( 0 , 4 )) #qc.u3(theta,0,0,1) #qc.u3(theta,0,0,2) #qc.u3(theta,0,0,3) qc . measure_all () return qc qc = bb84_states () + measure_circuit ( 0 ) qc . draw () \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 \u2591 \u250c\u2500\u2510 q_0: \u2524 U3(-pi/4,0,0) \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2591\u2500\u2524M\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 \u2514\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2518\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 \u2591 \u2514\u2565\u2518\u250c\u2500\u2510 q_1: \u2500\u2500\u2500\u2500\u2500\u2500\u2524 X \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2524 U3(-pi/4,0,0) \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2591\u2500\u2500\u256b\u2500\u2524M\u251c\u2500\u2500\u2500\u2500\u2500\u2500 \u251c\u2500\u2500\u2500\u2524 \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524 \u2591 \u2551 \u2514\u2565\u2518\u250c\u2500\u2510 q_2: \u2500\u2500\u2500\u2500\u2500\u2500\u2524 H \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2524 U3(-pi/4,0,0) \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2591\u2500\u2500\u256b\u2500\u2500\u256b\u2500\u2524M\u251c\u2500\u2500\u2500 \u251c\u2500\u2500\u2500\u2524 \u2514\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2518\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 \u2591 \u2551 \u2551 \u2514\u2565\u2518\u250c\u2500\u2510 q_3: \u2500\u2500\u2500\u2500\u2500\u2500\u2524 X \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524 H \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2524 U3(-pi/4,0,0) \u251c\u2500\u2591\u2500\u2500\u256b\u2500\u2500\u256b\u2500\u2500\u256b\u2500\u2524M\u251c \u2514\u2500\u2500\u2500\u2518 \u2514\u2500\u2500\u2500\u2518 \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518 \u2591 \u2551 \u2551 \u2551 \u2514\u2565\u2518 meas_0: \u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2569\u2550\u2550\u256c\u2550\u2550\u256c\u2550\u2550\u256c\u2550 \u2551 \u2551 \u2551 meas_1: \u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2569\u2550\u2550\u256c\u2550\u2550\u256c\u2550 \u2551 \u2551 meas_2: \u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2569\u2550\u2550\u256c\u2550 \u2551 meas_3: \u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2569\u2550 # OUTDATED CODE # SEE CELL BELOW FOR BATCH JOB from qiskit.tools.monitor import * def run_job ( qc ): # runs test on all inputs # run cicuits in one batch #job_manager = IBMQJobManager() #job_set = job_manager.run([qc_0, qc_1], backend=provider.get_backend('ibmq_qasm_simulator'), name='msrincom_test') #job_monitor(job_set) #job_set.error_message() job = execute ( qc , backend = provider . get_backend ( 'ibmq_qasm_simulator' ), shots = 1000 ) job_monitor ( job ) return job qc_0 = bb84_states () + measure_circuit ( 0 ) job = run_job ( qc_0 ) job . result () . get_counts ( qc_0 ) plot_histogram ( job . result () . get_counts ( qc_0 )) Job Status: job has successfully run from qiskit.tools.monitor import * def run_jobs ( qc ): # run cicuits in one batch job_manager = IBMQJobManager () job_set = job_manager . run ( qc , backend = provider . get_backend ( 'ibmq_qasm_simulator' ), name = 'msrincom_test' ) job_set . error_messages () return job_set qc_0 = bb84_states () + measure_circuit ( 0 ) qc_1 = bb84_states () + measure_circuit ( 1 ) managed_job = run_jobs ([ qc_0 , qc_1 ]) result_0 = managed_job . job ( 0 )[ 0 ] . result () result_1 = managed_job . job ( 1 )[ 0 ] . result () #managed_job.job(0)[0].error_message() result_0 . get_counts ( qc_0 ) {'0101': 2, '0111': 2, '1100': 18, '0100': 4, '1001': 9, '1010': 554, '0001': 1, '1111': 22, '1110': 94, '0010': 89, '0000': 16, '1011': 90, '0110': 21, '0011': 13, '1101': 4, '1000': 85} qc_1 = bb84_states () + measure_circuit ( 1 ) job2 = run_job ( qc_1 ) job2 . result () . get_counts ( qc_1 ) plot_histogram ( job2 . result () . get_counts ( qc_1 )) Job Status: job has successfully run counts = job2 . result () . get_counts ( qc_1 ) print ( counts ) # 2x4 matrix for probabilities # row for x # column for y bins = ( 2 , 4 ) bins = np . zeros ( bins ) # iterate over dictionary for state in counts : for i in range ( 0 , 4 ): r = int ( state [ i ]) c = 3 - i bins [ r , c ] += counts [ state ] print ( bins ) # convert bins to probibilities probs = bins / 1000.0 print ( probs ) {'0101': 17, '0111': 1, '0000': 15, '1100': 17, '1011': 66, '0100': 1, '1001': 540, '1010': 11, '0001': 96, '1111': 23, '0011': 13, '1110': 1, '1101': 105, '0010': 4, '1000': 90} [[139. 881. 835. 147.] [861. 119. 165. 853.]] [[0.139 0.881 0.835 0.147] [0.861 0.119 0.165 0.853]] from qiskit.quantum_info import Statevector qc = bb84_states () state = Statevector . from_instruction ( qc ) print ( state ) real_state = [ 0 , 0 , 0.5 + 0.j , 0 , 0 , 0 , 0.5 , 0 , 0 , 0 , - 0.5 , 0 , 0 , 0 , - 0.5 , 0 ] print ( state . data ) print ( state . data == real_state ) print ( state . data [ 2 ]) error = abs ( state . data - real_state ) epsilon = 1.0E-4 any ( x > epsilon for x in error ) Statevector([ 0. +0.j, 0. +0.j, 0.5+0.j, 0. +0.j, 0. +0.j, 0. +0.j, 0.5+0.j, 0. +0.j, 0. +0.j, 0. +0.j, -0.5+0.j, 0. +0.j, 0. +0.j, 0. +0.j, -0.5+0.j, 0. +0.j], dims=(2, 2, 2, 2)) [ 0. +0.j 0. +0.j 0.5+0.j 0. +0.j 0. +0.j 0. +0.j 0.5+0.j 0. +0.j 0. +0.j 0. +0.j -0.5+0.j 0. +0.j 0. +0.j 0. +0.j -0.5+0.j 0. +0.j] [ True True False True True True False True True True False True True True False True] (0.4999999999999999+0j) False Communicator Testing \u00b6 communicator = quantum_communicator . LocalCommunicator ([ provider . get_backend ( 'ibmq_qasm_simulator' )]) print ( communicator ) pre_operations = bb84_states () post_operations = ( QuantumCircuit ( 4 ), measure_circuit ( 0 )) display ( post_operations [ 1 ] . draw ()) size = max ( post_operations [ 0 ] . num_qubits , post_operations [ 1 ] . num_qubits ) print ( size ) counts = communicator . run_and_transmit ( \"nothing\" , \"nothing\" , pre_operations , post_operations , 1000 ) plot_histogram ( counts ) --------------------------------------------------------------------------- AttributeError Traceback (most recent call last) <ipython-input-13-9ff726b995fb> in <module> ----> 1 communicator = quantum_communicator.LocalCommunicator([provider.get_backend('ibmq_qasm_simulator')]) 2 print(communicator) 3 pre_operations = bb84_states() 4 post_operations = (QuantumCircuit(4),measure_circuit(0)) 5 display(post_operations[1].draw()) AttributeError: module 'device_independent_test.quantum_communicator' has no attribute 'LocalCommunicator' communicator = quantum_communicator . LocalCommunicator ([ provider . get_backend ( 'ibmq_qasm_simulator' )]) pre_operations = [ bb84_states (), bb84_states ()] post_operations = [[ QuantumCircuit ( 4 ), QuantumCircuit ( 4 )],[ measure_circuit ( 0 ), QuantumCircuit ( 4 )]] counts = communicator . batch_run_and_transmit ( \"\" , \"\" , pre_operations , post_operations , 1000 ) print ( counts ) test = [[ 1 , 2 , 3 ],[ 4 , 5 , 6 ],[ 7 , 8 , 9 ]] print ( test ) print ( test [ 0 ][ 2 ]) print ( test [ 1 ][ 0 ]) communicator = quantum_communicator . LocalCommunicator ([ provider . get_backend ( 'ibmq_qasm_simulator' )]) pre_operations = [ bb84_states (), QuantumCircuit ( 4 ), bb84_states ()] #post_operations = [[QuantumCircuit(4),QuantumCircuit(4),QuantumCircuit(4)],[measure_circuit(0),QuantumCircuit(4),measure_circuit(1)]] post_operations = [[ QuantumCircuit ( 4 ), measure_circuit ( 0 )],[ QuantumCircuit ( 4 ), QuantumCircuit ( 4 )],[ QuantumCircuit ( 4 ), QuantumCircuit ( 4 )]] count0 = communicator . run_and_transmit ( \"\" , \"\" , pre_operations [ 0 ], post_operations [ 0 ], 1000 ) #count1 = communicator.run_and_transmit(\"\",\"\",pre_operations[0],[post_operations[0][0],post_operations[1][0]],1000) #count2 = communicator.run_and_transmit(\"\",\"\",pre_operations[0],[post_operations[0][0],post_operations[1][0]],1000) count1 = communicator . run_and_transmit ( \"\" , \"\" , pre_operations [ 1 ], post_operations [ 1 ], 1000 ) count2 = communicator . run_and_transmit ( \"\" , \"\" , pre_operations [ 2 ], post_operations [ 2 ], 1000 ) print ( count2 ) #print(count1) #print(count2) print ( count0 ) circuits = [ bb84_states () + measure_circuit ( 0 ), bb84_states () + measure_circuit ( 1 ), bb84_states ()] job_manager = IBMQJobManager () job_set = execute ( circuits , backend = provider . get_backend ( 'ibmq_qasm_simulator' ), shots = 1000 ) # retrieve and return counts counts = [] for i in range ( 0 , len ( circuits )): if job_set . result () . data ( circuits [ i ]) == {}: counts . append ({ \"NO_MEASURMENT\" : 0 }) else : counts . append ( job_set . result () . get_counts ( circuits [ i ])) print ( counts ) result_1 = job_set . job ( 1 )[ 0 ] . result () counts = result_2 . get_counts ( circuits [ 1 ]) results = job_set . results () print ( results ) counts = results . data ( QuantumCircuit ( 2 )) print ( counts ) # Build a thousand circuits. from qiskit.circuit.random import random_circuit circs = [] for _ in range ( 10 ): circs . append ( random_circuit ( n_qubits = 5 , depth = 4 )) # Use Job Manager to break the circuits into multiple jobs. job_manager = IBMQJobManager () job_set_foo = job_manager . run ( circs , backend = provider . get_backend ( 'ibmq_qasm_simulator' ) , name = 'foo' ) testresults = job_set_foo . results () test5 = testresults . get_counts ( 5 )","title":"Incompatible Measurement Test"},{"location":"Incompatible_Measurement.html#measurement-incompatibility-testing","text":"# Make sure to load your IBM Q token before running the below block # Importing standard Qiskit libraries and configuring account from qiskit import QuantumCircuit , execute , IBMQ from qiskit.tools.jupyter import * from qiskit.visualization import * from qiskit.providers.ibmq.managed import IBMQJobManager # Loading your IBM Q account(s) provider = IBMQ . load_account () import matplotlib.pyplot as plt import numpy as np # custom code import context from device_independent_test import incompatible_measurement from device_independent_test import quantum_communicator def bb84_states (): # Alice's half of the circuit # creates 0,1,+,- qc = QuantumCircuit ( 4 ) qc . x ( 1 ) # create 1 qc . h ( 2 ) # create + qc . x ( 3 ) # create - qc . h ( 3 ) # ^ return qc def measure_circuit ( y ): # Bob's measurement circuit # measure in either pi/4 or 3pi/4 basis assert y == 0 or y == 1 , \"Bob's input should be 0 or 1\" qc = QuantumCircuit ( 4 ) theta = - 1.0 * ( np . pi / 4 + 0.5 * y * np . pi ) qc . u3 ( theta , 0 , 0 , range ( 0 , 4 )) #qc.u3(theta,0,0,1) #qc.u3(theta,0,0,2) #qc.u3(theta,0,0,3) qc . measure_all () return qc qc = bb84_states () + measure_circuit ( 0 ) qc . draw () \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 \u2591 \u250c\u2500\u2510 q_0: \u2524 U3(-pi/4,0,0) \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2591\u2500\u2524M\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 \u2514\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2518\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 \u2591 \u2514\u2565\u2518\u250c\u2500\u2510 q_1: \u2500\u2500\u2500\u2500\u2500\u2500\u2524 X \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2524 U3(-pi/4,0,0) \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2591\u2500\u2500\u256b\u2500\u2524M\u251c\u2500\u2500\u2500\u2500\u2500\u2500 \u251c\u2500\u2500\u2500\u2524 \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524 \u2591 \u2551 \u2514\u2565\u2518\u250c\u2500\u2510 q_2: \u2500\u2500\u2500\u2500\u2500\u2500\u2524 H \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2524 U3(-pi/4,0,0) \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2591\u2500\u2500\u256b\u2500\u2500\u256b\u2500\u2524M\u251c\u2500\u2500\u2500 \u251c\u2500\u2500\u2500\u2524 \u2514\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2518\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 \u2591 \u2551 \u2551 \u2514\u2565\u2518\u250c\u2500\u2510 q_3: \u2500\u2500\u2500\u2500\u2500\u2500\u2524 X \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524 H \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2524 U3(-pi/4,0,0) \u251c\u2500\u2591\u2500\u2500\u256b\u2500\u2500\u256b\u2500\u2500\u256b\u2500\u2524M\u251c \u2514\u2500\u2500\u2500\u2518 \u2514\u2500\u2500\u2500\u2518 \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518 \u2591 \u2551 \u2551 \u2551 \u2514\u2565\u2518 meas_0: \u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2569\u2550\u2550\u256c\u2550\u2550\u256c\u2550\u2550\u256c\u2550 \u2551 \u2551 \u2551 meas_1: \u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2569\u2550\u2550\u256c\u2550\u2550\u256c\u2550 \u2551 \u2551 meas_2: \u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2569\u2550\u2550\u256c\u2550 \u2551 meas_3: \u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2569\u2550 # OUTDATED CODE # SEE CELL BELOW FOR BATCH JOB from qiskit.tools.monitor import * def run_job ( qc ): # runs test on all inputs # run cicuits in one batch #job_manager = IBMQJobManager() #job_set = job_manager.run([qc_0, qc_1], backend=provider.get_backend('ibmq_qasm_simulator'), name='msrincom_test') #job_monitor(job_set) #job_set.error_message() job = execute ( qc , backend = provider . get_backend ( 'ibmq_qasm_simulator' ), shots = 1000 ) job_monitor ( job ) return job qc_0 = bb84_states () + measure_circuit ( 0 ) job = run_job ( qc_0 ) job . result () . get_counts ( qc_0 ) plot_histogram ( job . result () . get_counts ( qc_0 )) Job Status: job has successfully run from qiskit.tools.monitor import * def run_jobs ( qc ): # run cicuits in one batch job_manager = IBMQJobManager () job_set = job_manager . run ( qc , backend = provider . get_backend ( 'ibmq_qasm_simulator' ), name = 'msrincom_test' ) job_set . error_messages () return job_set qc_0 = bb84_states () + measure_circuit ( 0 ) qc_1 = bb84_states () + measure_circuit ( 1 ) managed_job = run_jobs ([ qc_0 , qc_1 ]) result_0 = managed_job . job ( 0 )[ 0 ] . result () result_1 = managed_job . job ( 1 )[ 0 ] . result () #managed_job.job(0)[0].error_message() result_0 . get_counts ( qc_0 ) {'0101': 2, '0111': 2, '1100': 18, '0100': 4, '1001': 9, '1010': 554, '0001': 1, '1111': 22, '1110': 94, '0010': 89, '0000': 16, '1011': 90, '0110': 21, '0011': 13, '1101': 4, '1000': 85} qc_1 = bb84_states () + measure_circuit ( 1 ) job2 = run_job ( qc_1 ) job2 . result () . get_counts ( qc_1 ) plot_histogram ( job2 . result () . get_counts ( qc_1 )) Job Status: job has successfully run counts = job2 . result () . get_counts ( qc_1 ) print ( counts ) # 2x4 matrix for probabilities # row for x # column for y bins = ( 2 , 4 ) bins = np . zeros ( bins ) # iterate over dictionary for state in counts : for i in range ( 0 , 4 ): r = int ( state [ i ]) c = 3 - i bins [ r , c ] += counts [ state ] print ( bins ) # convert bins to probibilities probs = bins / 1000.0 print ( probs ) {'0101': 17, '0111': 1, '0000': 15, '1100': 17, '1011': 66, '0100': 1, '1001': 540, '1010': 11, '0001': 96, '1111': 23, '0011': 13, '1110': 1, '1101': 105, '0010': 4, '1000': 90} [[139. 881. 835. 147.] [861. 119. 165. 853.]] [[0.139 0.881 0.835 0.147] [0.861 0.119 0.165 0.853]] from qiskit.quantum_info import Statevector qc = bb84_states () state = Statevector . from_instruction ( qc ) print ( state ) real_state = [ 0 , 0 , 0.5 + 0.j , 0 , 0 , 0 , 0.5 , 0 , 0 , 0 , - 0.5 , 0 , 0 , 0 , - 0.5 , 0 ] print ( state . data ) print ( state . data == real_state ) print ( state . data [ 2 ]) error = abs ( state . data - real_state ) epsilon = 1.0E-4 any ( x > epsilon for x in error ) Statevector([ 0. +0.j, 0. +0.j, 0.5+0.j, 0. +0.j, 0. +0.j, 0. +0.j, 0.5+0.j, 0. +0.j, 0. +0.j, 0. +0.j, -0.5+0.j, 0. +0.j, 0. +0.j, 0. +0.j, -0.5+0.j, 0. +0.j], dims=(2, 2, 2, 2)) [ 0. +0.j 0. +0.j 0.5+0.j 0. +0.j 0. +0.j 0. +0.j 0.5+0.j 0. +0.j 0. +0.j 0. +0.j -0.5+0.j 0. +0.j 0. +0.j 0. +0.j -0.5+0.j 0. +0.j] [ True True False True True True False True True True False True True True False True] (0.4999999999999999+0j) False","title":"Measurement Incompatibility Testing"},{"location":"Incompatible_Measurement.html#communicator-testing","text":"communicator = quantum_communicator . LocalCommunicator ([ provider . get_backend ( 'ibmq_qasm_simulator' )]) print ( communicator ) pre_operations = bb84_states () post_operations = ( QuantumCircuit ( 4 ), measure_circuit ( 0 )) display ( post_operations [ 1 ] . draw ()) size = max ( post_operations [ 0 ] . num_qubits , post_operations [ 1 ] . num_qubits ) print ( size ) counts = communicator . run_and_transmit ( \"nothing\" , \"nothing\" , pre_operations , post_operations , 1000 ) plot_histogram ( counts ) --------------------------------------------------------------------------- AttributeError Traceback (most recent call last) <ipython-input-13-9ff726b995fb> in <module> ----> 1 communicator = quantum_communicator.LocalCommunicator([provider.get_backend('ibmq_qasm_simulator')]) 2 print(communicator) 3 pre_operations = bb84_states() 4 post_operations = (QuantumCircuit(4),measure_circuit(0)) 5 display(post_operations[1].draw()) AttributeError: module 'device_independent_test.quantum_communicator' has no attribute 'LocalCommunicator' communicator = quantum_communicator . LocalCommunicator ([ provider . get_backend ( 'ibmq_qasm_simulator' )]) pre_operations = [ bb84_states (), bb84_states ()] post_operations = [[ QuantumCircuit ( 4 ), QuantumCircuit ( 4 )],[ measure_circuit ( 0 ), QuantumCircuit ( 4 )]] counts = communicator . batch_run_and_transmit ( \"\" , \"\" , pre_operations , post_operations , 1000 ) print ( counts ) test = [[ 1 , 2 , 3 ],[ 4 , 5 , 6 ],[ 7 , 8 , 9 ]] print ( test ) print ( test [ 0 ][ 2 ]) print ( test [ 1 ][ 0 ]) communicator = quantum_communicator . LocalCommunicator ([ provider . get_backend ( 'ibmq_qasm_simulator' )]) pre_operations = [ bb84_states (), QuantumCircuit ( 4 ), bb84_states ()] #post_operations = [[QuantumCircuit(4),QuantumCircuit(4),QuantumCircuit(4)],[measure_circuit(0),QuantumCircuit(4),measure_circuit(1)]] post_operations = [[ QuantumCircuit ( 4 ), measure_circuit ( 0 )],[ QuantumCircuit ( 4 ), QuantumCircuit ( 4 )],[ QuantumCircuit ( 4 ), QuantumCircuit ( 4 )]] count0 = communicator . run_and_transmit ( \"\" , \"\" , pre_operations [ 0 ], post_operations [ 0 ], 1000 ) #count1 = communicator.run_and_transmit(\"\",\"\",pre_operations[0],[post_operations[0][0],post_operations[1][0]],1000) #count2 = communicator.run_and_transmit(\"\",\"\",pre_operations[0],[post_operations[0][0],post_operations[1][0]],1000) count1 = communicator . run_and_transmit ( \"\" , \"\" , pre_operations [ 1 ], post_operations [ 1 ], 1000 ) count2 = communicator . run_and_transmit ( \"\" , \"\" , pre_operations [ 2 ], post_operations [ 2 ], 1000 ) print ( count2 ) #print(count1) #print(count2) print ( count0 ) circuits = [ bb84_states () + measure_circuit ( 0 ), bb84_states () + measure_circuit ( 1 ), bb84_states ()] job_manager = IBMQJobManager () job_set = execute ( circuits , backend = provider . get_backend ( 'ibmq_qasm_simulator' ), shots = 1000 ) # retrieve and return counts counts = [] for i in range ( 0 , len ( circuits )): if job_set . result () . data ( circuits [ i ]) == {}: counts . append ({ \"NO_MEASURMENT\" : 0 }) else : counts . append ( job_set . result () . get_counts ( circuits [ i ])) print ( counts ) result_1 = job_set . job ( 1 )[ 0 ] . result () counts = result_2 . get_counts ( circuits [ 1 ]) results = job_set . results () print ( results ) counts = results . data ( QuantumCircuit ( 2 )) print ( counts ) # Build a thousand circuits. from qiskit.circuit.random import random_circuit circs = [] for _ in range ( 10 ): circs . append ( random_circuit ( n_qubits = 5 , depth = 4 )) # Use Job Manager to break the circuits into multiple jobs. job_manager = IBMQJobManager () job_set_foo = job_manager . run ( circs , backend = provider . get_backend ( 'ibmq_qasm_simulator' ) , name = 'foo' ) testresults = job_set_foo . results () test5 = testresults . get_counts ( 5 )","title":"Communicator Testing"},{"location":"Quantum_Communicator_Example.html","text":"# Importing standard Qiskit libraries and configuring account from qiskit import QuantumCircuit , IBMQ from qiskit.tools.jupyter import * from qiskit.visualization import * from qiskit.providers.ibmq.managed import IBMQJobManager # Loading your IBM Q account(s) import qiskit from qiskit import IBMQ provider = IBMQ . load_account () import numpy as np import context from device_independent_test import quantum_communicator from device_independent_test import incompatible_measurement Using the QuantumDispatcher Class \u00b6 A Dispatcher has 3 functions: run_and_transmit(), multi_run_and_transmit(), and batch_run_and_transmit(). Run_and_transmit takes in 5 parameters: input registers, output registers, a circuit of operations to prepare a transmitted state, a list operations to run on different devices, and the number of shots. Run_and_transmit() is intended to run a single job. Multi_run_and_transmit takes in similar parameters. However, the preparation operations are now expected to be a list of operations. Similarly, the post operations are expected to be a list of lists. The ith element of each list corresponds to the circuit ran as the ith job. Batch_run_and_transmit creates and runs all permutations of operations given to it, both pre and post transmission. The cell below first creates a list of two operations to run to prepare states. Next, a list of two lists is created to define the operations desired after transmission. The first operation is the bb84 states and then Bob's measurement with y=0. The second is the bb84 states transmitted to Bob who measures when y=1. To create the dispatcher, a list of devices is required in the constructor. As this is a local dispatcher, only one device is required. Next, a multi run is executed and the counts are stored. pre_ops = [ incompatible_measurement . bb84_states (), incompatible_measurement . bb84_states ()] post_ops = [[ QuantumCircuit ( 4 ), QuantumCircuit ( 4 )], [ incompatible_measurement . measure_circuit ( 0 ), incompatible_measurement . measure_circuit ( 1 )]] dispatch = quantum_communicator . LocalDispatcher ([ provider . get_backend ( 'ibmq_qasm_simulator' )]) counts = dispatch . multi_run_and_transmit ( \"\" , \"\" , pre_ops , post_ops , 1000 ) print ( counts ) [{'0000': 17, '0111': 3, '1011': 97, '1100': 12, '1001': 16, '1111': 17, '0100': 5, '0010': 93, '0110': 16, '0011': 24, '1000': 102, '1010': 491, '0001': 7, '1110': 99, '1101': 1}, {'0000': 19, '0111': 4, '1011': 99, '1100': 18, '1001': 533, '1111': 13, '0100': 3, '0101': 20, '0010': 4, '0011': 12, '1000': 95, '1010': 11, '0001': 81, '1110': 3, '1101': 85}]","title":"Dispatcher Example"},{"location":"Quantum_Communicator_Example.html#using-the-quantumdispatcher-class","text":"A Dispatcher has 3 functions: run_and_transmit(), multi_run_and_transmit(), and batch_run_and_transmit(). Run_and_transmit takes in 5 parameters: input registers, output registers, a circuit of operations to prepare a transmitted state, a list operations to run on different devices, and the number of shots. Run_and_transmit() is intended to run a single job. Multi_run_and_transmit takes in similar parameters. However, the preparation operations are now expected to be a list of operations. Similarly, the post operations are expected to be a list of lists. The ith element of each list corresponds to the circuit ran as the ith job. Batch_run_and_transmit creates and runs all permutations of operations given to it, both pre and post transmission. The cell below first creates a list of two operations to run to prepare states. Next, a list of two lists is created to define the operations desired after transmission. The first operation is the bb84 states and then Bob's measurement with y=0. The second is the bb84 states transmitted to Bob who measures when y=1. To create the dispatcher, a list of devices is required in the constructor. As this is a local dispatcher, only one device is required. Next, a multi run is executed and the counts are stored. pre_ops = [ incompatible_measurement . bb84_states (), incompatible_measurement . bb84_states ()] post_ops = [[ QuantumCircuit ( 4 ), QuantumCircuit ( 4 )], [ incompatible_measurement . measure_circuit ( 0 ), incompatible_measurement . measure_circuit ( 1 )]] dispatch = quantum_communicator . LocalDispatcher ([ provider . get_backend ( 'ibmq_qasm_simulator' )]) counts = dispatch . multi_run_and_transmit ( \"\" , \"\" , pre_ops , post_ops , 1000 ) print ( counts ) [{'0000': 17, '0111': 3, '1011': 97, '1100': 12, '1001': 16, '1111': 17, '0100': 5, '0010': 93, '0110': 16, '0011': 24, '1000': 102, '1010': 491, '0001': 7, '1110': 99, '1101': 1}, {'0000': 19, '0111': 4, '1011': 99, '1100': 18, '1001': 533, '1111': 13, '0100': 3, '0101': 20, '0010': 4, '0011': 12, '1000': 95, '1010': 11, '0001': 81, '1110': 3, '1101': 85}]","title":"Using the QuantumDispatcher Class"},{"location":"Theory_for_Incompatible_Measurement_Test.html","text":"A Single-Qubit Bell Violation as a Device-Independent Test \u00b6 This notebook describe the quantum violation of a novel bell inequality bounding classical communication systems. The Bell violation does not require entanglement and is achieved by incompatible measurements and qubit superposition alone. Generally, a Bell violation describes non-classical measurement statistics which can only be achieved by a quantum system. That is, Alice and Bob cannot violate a Bell inequality using a classical system and shared randomness. The quantum-classical separation allows for a strong device independent test to be setup provided the following assumptions hold: Test Assumptions: \u00b6 Alice and Bob receive independent input drawn from uniform random distributions. Alice sends Bob no more than 1-bit or 1-qubit. If the assumptions are met, a single-qubit bell violation is sufficient to classify the bipartite communication system as a quantum communication system capable of superposition and incompatible measurements. In an ideal implementation where the communication channel is proven to be limited, Alice and Bob do not need to be trusted. If it is not possible to verify the channel capacity, then Alice or Bob must be trusted for the test to work. Note: Supporting Software \u00b6 The following Bell inequality and quantum violation were found using the open-source julia package, BellScenario.jl . This package is currently in an alpha version and is unfortunately experiencing a bug which prevents proper execution within a Jupyter notebook. The result is reported in the following cells. Test Setting \u00b6 We consider a single-qubit scenario where Alice and Bob each have a black-box with classical inputs and outputs. Alice is given an input, x\\in\\{0,1,2,3\\} x\\in\\{0,1,2,3\\} and encodes the value in a qubit, \\rho_x \\rho_x . The qubit is sent to Bob via some communication channel. Bob receives the qubit and performs a projective measurement based on the input y\\in\\{0,1\\} y\\in\\{0,1\\} . The outcome of the measurement, b\\in\\{0,1\\} b\\in\\{0,1\\} is output by Bob. This black-box scenario is characterized in a device-independent way by considering its set of conditional probabilities \\{p(b|xy)\\} \\{p(b|xy)\\} . The conditional probability distribution or behavior of a black-box device can be considered as a vector \\vec{p} \\vec{p} where each element corresponds to a different probability p(b|xy) p(b|xy) . The Classical Bound \u00b6 The classical set of probabilities \\mathcal{C} \\mathcal{C} is the convex hull of the deterministic black-box behaviors, \\mathcal{C} = \\text{conv}(\\vec{p}_D) \\mathcal{C} = \\text{conv}(\\vec{p}_D) . A behavior is deterministic if p(b|xy)\\in \\{0,1\\} p(b|xy)\\in \\{0,1\\} for all b b , x x , and y y . The deterministic behaviors of a black-box scenario are finite and therefore describe a convex polytope. A Bell inequality is a linear inequality that bounds the classical polytope for a black-box scenario. Given the inputs, outputs, and communication between Alice and Bob, the bell inequalities can be computed. The procedure is to first enumerate the deterministic behaviors, then use a polytope transformation algorithm to find the bounding inequalities. The vertices and facets used for this result are computed using the BellScenario.jl julia package. A significant Bell inequality for which there is a quantum violation is expressed, 6 \\geq \\Big(p(0|00) + p(1|10) + p(0|20) + p(1|30)\\Big) + \\Big(p(1|01) + p(0|11) + p(0|21) + p(1|31)\\Big). 6 \\geq \\Big(p(0|00) + p(1|10) + p(0|20) + p(1|30)\\Big) + \\Big(p(1|01) + p(0|11) + p(0|21) + p(1|31)\\Big). This inequality may be daunting, but it can be broken down by Bob's input y=0 y=0 (left) and y=1 y=1 (right). It is important to reiterate that Alice and Bob do not know each other's input. Alice's Best strategy is to use an encoding such as 0,2 \\rightarrow |0\\rangle 0,2 \\rightarrow |0\\rangle and 1,3 \\rightarrow |1\\rangle 1,3 \\rightarrow |1\\rangle , while Bob performs and identity decoding for y=0 y=0 and an inverted decoding for y=1 y=1 . Explicitly, the identity decoder is \\{|0\\rangle\\langle0|,|1\\rangle\\langle1|\\} \\{|0\\rangle\\langle0|,|1\\rangle\\langle1|\\} and the inverting decoder is \\{|0\\rangle\\langle1|,|1\\rangle\\langle0| \\} \\{|0\\rangle\\langle1|,|1\\rangle\\langle0| \\} . However, a closer look at the bell inequality reveals that when y=1 y=1 , a violation would require Bob to be able to invert only the received but only when Alice has input x\\in\\{0,1\\} x\\in\\{0,1\\} . Bob does not know Alice's inputs, so there is no way for Bob to condition a decoding strategy on Alice's input. As a result, classical communication limited systems cannot violate the bell inequality. In the case where Alice is able to share the input x x with Bob, a conditional decoding strategy could be applied and a violation would occur. This edge case is precisely why the communication channel must be limited to a single bit or qubit of information. Quantum Violation \u00b6 Quantum mechanics can violate the discussed Bell inequality using the following protocol. This protocol was computed using the BellScenario.jl julia package to optimize the quantum violation using semi-definite programming. Alice encodes the input x x into a BB84 qubit state |\\psi_x\\rangle |\\psi_x\\rangle where |\\psi_0\\rangle = |0\\rangle |\\psi_0\\rangle = |0\\rangle , |\\psi_1\\rangle =|1\\rangle |\\psi_1\\rangle =|1\\rangle , |\\psi_2\\rangle = |+\\rangle |\\psi_2\\rangle = |+\\rangle , |\\psi_3\\rangle = |-\\rangle |\\psi_3\\rangle = |-\\rangle . Bob measures with a projective measurement onto a basis rotated off the BB84 states by an angle \\theta=\\pi/4 \\theta=\\pi/4 . The measurement bases for each input y y are expressed \\begin{align} &|\\Pi_0^{y=0}\\rangle = \\cos(\\pi/8)|0\\rangle + \\sin(\\pi/8)|1\\rangle, \\quad |\\Pi_1^{y=0}\\rangle = \\sin(\\pi/8)|0\\rangle - \\cos(\\pi/8)|1\\rangle \\\\ &|\\Pi_0^{y=1}\\rangle = \\cos(3\\pi/8)|0\\rangle + \\sin(3\\pi/8)|1\\rangle, \\quad |\\Pi_1^{y=1}\\rangle = \\sin(3\\pi/8)|0\\rangle - \\cos(3\\pi/8)|1\\rangle \\\\ \\end{align} \\begin{align} &|\\Pi_0^{y=0}\\rangle = \\cos(\\pi/8)|0\\rangle + \\sin(\\pi/8)|1\\rangle, \\quad |\\Pi_1^{y=0}\\rangle = \\sin(\\pi/8)|0\\rangle - \\cos(\\pi/8)|1\\rangle \\\\ &|\\Pi_0^{y=1}\\rangle = \\cos(3\\pi/8)|0\\rangle + \\sin(3\\pi/8)|1\\rangle, \\quad |\\Pi_1^{y=1}\\rangle = \\sin(3\\pi/8)|0\\rangle - \\cos(3\\pi/8)|1\\rangle \\\\ \\end{align} Since the quantum states consist of |0/1\\rangle |0/1\\rangle and |+/-\\rangle |+/-\\rangle bases, they require superposition to construct. Likewise, the quantum measurements are incompatible because the two measurement sets align with rotated |0/1\\rangle |0/1\\rangle and |+/-\\rangle |+/-\\rangle bases and therefore do not commute. On Bloch sphere, the states and measurements lie within the x x - z z -plane and take the following orientation. The conditional probabilities of each outcome are computed through the inner product, p(b|xy) = |\\langle\\Pi_b^y|\\psi_x\\rangle|^2 = \\cos^2(\\phi/2) p(b|xy) = |\\langle\\Pi_b^y|\\psi_x\\rangle|^2 = \\cos^2(\\phi/2) , where \\phi \\phi is the angle of separation between |\\psi_x\\rangle |\\psi_x\\rangle , and |\\Pi_b^y\\rangle |\\Pi_b^y\\rangle on Bloch sphere. By the symmetry of the BB84 states \\phi \\phi can be one of two values \\pi/4 \\pi/4 or 3\\pi/4 3\\pi/4 , therefore, p(b|xy)\\in \\{\\cos^2(\\pi/8),\\cos^2(3\\pi/8)\\} p(b|xy)\\in \\{\\cos^2(\\pi/8),\\cos^2(3\\pi/8)\\} . Computing the conditional probabilities for the classical bound, it is found that each of the probabilities in the inequality take on the value p(b|xy) = \\cos^2(\\pi/8) p(b|xy) = \\cos^2(\\pi/8) . Summing up all of the conditional probabilities in the inequality, a violation is found, 8\\cos^2(\\pi/8) = 6.818 \\nleq 6. 8\\cos^2(\\pi/8) = 6.818 \\nleq 6. The protocol violates the classical bound by 13.6\\% 13.6\\% . The quantum violation occurs with a single qubit. There is no entanglement, only superposition and measurement incompatibility. Analyzing the Quantum Violation \u00b6 This analysis shows: The quantum protocol violates and is optimal with respect to rotation of measurments. Violation does not occur if compatible measurments are used on the BB84 states. Violation does not occur if classical states are used with incompatible measurements. It can be concluded that superposition and measurement incompatibility are both required for a violation to occur in this protocol. The case of classical states and compatible measurements is not considered because such a scenario would be classical and would therefore be bounded by the derived Bell inequality. Setup \u00b6 # imports % matplotlib inline import matplotlib.pyplot as plt import numpy as np import context from device_independent_test import incompatible_measurement Quantum States \u00b6 We first define Alice's qubits. The BB84 states are are encoded as \\{|0\\rangle, |1\\rangle, |+\\rangle, |-\\rangle\\} \\{|0\\rangle, |1\\rangle, |+\\rangle, |-\\rangle\\} , and the classical states are encoded as \\{|0\\rangle, |1\\rangle, |0\\rangle, |1\\rangle\\} \\{|0\\rangle, |1\\rangle, |0\\rangle, |1\\rangle\\} . We note that the the classical states will achieve the classical bound if measured in the computational basis. # qubit states \u03c8 0 = [ 1 , 0 ] \u03c8 1 = [ 0 , 1 ] \u03c8 2 = [ 1 , 1 ] / np . sqrt ( 2 ) \u03c8 3 = [ 1 , - 1 ] / np . sqrt ( 2 ) # quantum state encodings \u03c8 _bb84 = [ \u03c8 0 , \u03c8 1 , \u03c8 2 , \u03c8 3 ] \u03c8 _classical = [ \u03c8 0 , \u03c8 1 , \u03c8 0 , \u03c8 1 ] Quantum Measurements \u00b6 We define Bob's measurements as two pairs of projective measurements. Each measurement has two outputs specified by b b and each measurement is used conditionally based on Bob's input y y . We wish to see how these quantum stategies perform against misalignment of devices so we will scan the measurements over an angle \\theta \\theta . # projective measurements \u03a0by \u03a0 00 = lambda \u03b8 : [ np . cos ( \u03b8 ), np . sin ( \u03b8 )] \u03a0 10 = lambda \u03b8 : [ np . sin ( \u03b8 ), - np . cos ( \u03b8 )] \u03a0 01 = lambda \u03b8 : [ np . cos ( \u03b8 + np . pi / 4 ), np . sin ( \u03b8 + np . pi / 4 )] \u03a0 11 = lambda \u03b8 : [ np . sin ( \u03b8 + np . pi / 4 ), - np . cos ( \u03b8 + np . pi / 4 )] # incompatible projective measurments y0_\u03a0 = [ \u03a0 00 , \u03a0 10 ] y1_\u03a0 = [ \u03a0 01 , \u03a0 11 ] # measurement compatible with y0_\u03a0 y1_cl_\u03a0 = [ \u03a0 10 , \u03a0 00 ] Calculating Performance Against the Classical Bound \u00b6 We begin by defining some lists to collect data into: classical_bound = [] # bb84 states with in/compatible measurements bb84_incompatible_scores = [] bb84_compatible_scores = [] # classical states with incompatible measurements cl_incompatible_scores = [] We now compute the score against the Bell inequality for a range of rotation angles, \\theta \\in [0, \\pi/2] \\theta \\in [0, \\pi/2] . # Measurement angle on a hilbert space \u03b8 _series = np . arange ( 0 , np . pi / 2 , np . pi / 2048 ) # computing the bell scores as the measurements are rotated about the y-axis. for \u03b8 in \u03b8 _series : # conditional probability matrices y0_probs = np . zeros (( 2 , 4 )) y0_cl_probs = np . zeros (( 2 , 4 )) y1_probs = np . zeros (( 2 , 4 )) y1_cl_incomp_probs = np . zeros (( 2 , 4 )) y1_comp_probs = np . zeros (( 2 , 4 )) for x in range ( 0 , 4 ): \u03c8 x_bb84 = \u03c8 _bb84 [ x ] \u03c8 x_cl = \u03c8 _classical [ x ] for b in range ( 0 , 2 ): # y=0 measurement \u03a0 b0 = y0_\u03a0 [ b ] y0_probs [ b , x ] = np . inner ( \u03a0 b0 ( \u03b8 ), \u03c8 x_bb84 ) ** 2 y0_cl_probs [ b , x ] = np . inner ( \u03a0 b0 ( \u03b8 ), \u03c8 x_cl ) ** 2 # y=1 incompatible measurement \u03a0 b1 = y1_\u03a0 [ b ] y1_probs [ b , x ] = np . inner ( \u03a0 b1 ( \u03b8 ), \u03c8 x_bb84 ) ** 2 y1_cl_incomp_probs [ b , x ] = np . inner ( \u03a0 b1 ( \u03b8 ), \u03c8 x_cl ) ** 2 # y=1 compatible measurement \u03a0 b1_comp = y1_cl_\u03a0 [ b ] y1_comp_probs [ b , x ] = np . inner ( \u03a0 b1_comp ( \u03b8 ), \u03c8 x_bb84 ) ** 2 # aggregating scores into arrays of data bb84_incompatible_scores . append ( incompatible_measurement . bell_score ( y0_probs , y1_probs )) bb84_compatible_scores . append ( incompatible_measurement . bell_score ( y0_probs , y0_probs )) cl_incompatible_scores . append ( incompatible_measurement . bell_score ( y0_cl_probs , y1_cl_incomp_probs )) classical_bound . append ( 6 ) Plot of Violating and Nonviolating Quantum Scenarios \u00b6 The discussed quantum protocol violates with the Max Quantum Violation of 6.818 6.818 . The Incompatible Measurements plot shows that if measurments are rotated in either direction, the violation decreases. This implies that the discussed protocol has been aligned in the optimal fashion. The Compatible Measurments plot shows that there is no rotation angle for which compatible measurements can violate the quantum bound. The conclusion is that superposition is necessary for this violation, but is not sufficient on its own. Measurment incompatiblity must also be applied. cl_bound_plt , = plt . plot ( \u03b8 _series , classical_bound , label = 'Classical Bound' ) # bb84 states incompatible measurments bb84_incomp_plt , = plt . plot ( \u03b8 _series , bb84_incompatible_scores , label = 'Incomp Measurment' , linestyle = '-.' ) # bb84 states compatible measurments bb84_comp_plt , = plt . plot ( \u03b8 _series , bb84_compatible_scores , label = \"Comp Measurement\" , linestyle = '--' ) # classical states incompatible measurements cl_incomp_plt , = plt . plot ( \u03b8 _series , cl_incompatible_scores , label = \"cl incomp\" , linestyle = \":\" ) max_violation , = plt . plot ( np . pi / 8 , 6.828 , 'ro' , label = \"Max Quantum Violation\" ) plt . legend ( [ max_violation , bb84_incomp_plt , cl_bound_plt , bb84_comp_plt , cl_incomp_plt ], [ 'Max Quantum Violation' , 'BB84 & Incompatible Measurements' , 'Classical Bound' , 'BB84 & Compatible Measurements' , 'Classical & Incompatible Measurements' ]) plt . xlabel ( \"Measurement Rotation Angle (radians)\" ) plt . ylabel ( \"Bell Score\" ) plt . title ( \"Quantum State Measurements vs. Angle\" );","title":"Verifying Measurements"},{"location":"Theory_for_Incompatible_Measurement_Test.html#a-single-qubit-bell-violation-as-a-device-independent-test","text":"This notebook describe the quantum violation of a novel bell inequality bounding classical communication systems. The Bell violation does not require entanglement and is achieved by incompatible measurements and qubit superposition alone. Generally, a Bell violation describes non-classical measurement statistics which can only be achieved by a quantum system. That is, Alice and Bob cannot violate a Bell inequality using a classical system and shared randomness. The quantum-classical separation allows for a strong device independent test to be setup provided the following assumptions hold:","title":"A Single-Qubit Bell Violation as a Device-Independent Test"},{"location":"Theory_for_Incompatible_Measurement_Test.html#test-assumptions","text":"Alice and Bob receive independent input drawn from uniform random distributions. Alice sends Bob no more than 1-bit or 1-qubit. If the assumptions are met, a single-qubit bell violation is sufficient to classify the bipartite communication system as a quantum communication system capable of superposition and incompatible measurements. In an ideal implementation where the communication channel is proven to be limited, Alice and Bob do not need to be trusted. If it is not possible to verify the channel capacity, then Alice or Bob must be trusted for the test to work.","title":"Test Assumptions:"},{"location":"Theory_for_Incompatible_Measurement_Test.html#note-supporting-software","text":"The following Bell inequality and quantum violation were found using the open-source julia package, BellScenario.jl . This package is currently in an alpha version and is unfortunately experiencing a bug which prevents proper execution within a Jupyter notebook. The result is reported in the following cells.","title":"Note: Supporting Software"},{"location":"Theory_for_Incompatible_Measurement_Test.html#test-setting","text":"We consider a single-qubit scenario where Alice and Bob each have a black-box with classical inputs and outputs. Alice is given an input, x\\in\\{0,1,2,3\\} x\\in\\{0,1,2,3\\} and encodes the value in a qubit, \\rho_x \\rho_x . The qubit is sent to Bob via some communication channel. Bob receives the qubit and performs a projective measurement based on the input y\\in\\{0,1\\} y\\in\\{0,1\\} . The outcome of the measurement, b\\in\\{0,1\\} b\\in\\{0,1\\} is output by Bob. This black-box scenario is characterized in a device-independent way by considering its set of conditional probabilities \\{p(b|xy)\\} \\{p(b|xy)\\} . The conditional probability distribution or behavior of a black-box device can be considered as a vector \\vec{p} \\vec{p} where each element corresponds to a different probability p(b|xy) p(b|xy) .","title":"Test Setting"},{"location":"Theory_for_Incompatible_Measurement_Test.html#the-classical-bound","text":"The classical set of probabilities \\mathcal{C} \\mathcal{C} is the convex hull of the deterministic black-box behaviors, \\mathcal{C} = \\text{conv}(\\vec{p}_D) \\mathcal{C} = \\text{conv}(\\vec{p}_D) . A behavior is deterministic if p(b|xy)\\in \\{0,1\\} p(b|xy)\\in \\{0,1\\} for all b b , x x , and y y . The deterministic behaviors of a black-box scenario are finite and therefore describe a convex polytope. A Bell inequality is a linear inequality that bounds the classical polytope for a black-box scenario. Given the inputs, outputs, and communication between Alice and Bob, the bell inequalities can be computed. The procedure is to first enumerate the deterministic behaviors, then use a polytope transformation algorithm to find the bounding inequalities. The vertices and facets used for this result are computed using the BellScenario.jl julia package. A significant Bell inequality for which there is a quantum violation is expressed, 6 \\geq \\Big(p(0|00) + p(1|10) + p(0|20) + p(1|30)\\Big) + \\Big(p(1|01) + p(0|11) + p(0|21) + p(1|31)\\Big). 6 \\geq \\Big(p(0|00) + p(1|10) + p(0|20) + p(1|30)\\Big) + \\Big(p(1|01) + p(0|11) + p(0|21) + p(1|31)\\Big). This inequality may be daunting, but it can be broken down by Bob's input y=0 y=0 (left) and y=1 y=1 (right). It is important to reiterate that Alice and Bob do not know each other's input. Alice's Best strategy is to use an encoding such as 0,2 \\rightarrow |0\\rangle 0,2 \\rightarrow |0\\rangle and 1,3 \\rightarrow |1\\rangle 1,3 \\rightarrow |1\\rangle , while Bob performs and identity decoding for y=0 y=0 and an inverted decoding for y=1 y=1 . Explicitly, the identity decoder is \\{|0\\rangle\\langle0|,|1\\rangle\\langle1|\\} \\{|0\\rangle\\langle0|,|1\\rangle\\langle1|\\} and the inverting decoder is \\{|0\\rangle\\langle1|,|1\\rangle\\langle0| \\} \\{|0\\rangle\\langle1|,|1\\rangle\\langle0| \\} . However, a closer look at the bell inequality reveals that when y=1 y=1 , a violation would require Bob to be able to invert only the received but only when Alice has input x\\in\\{0,1\\} x\\in\\{0,1\\} . Bob does not know Alice's inputs, so there is no way for Bob to condition a decoding strategy on Alice's input. As a result, classical communication limited systems cannot violate the bell inequality. In the case where Alice is able to share the input x x with Bob, a conditional decoding strategy could be applied and a violation would occur. This edge case is precisely why the communication channel must be limited to a single bit or qubit of information.","title":"The Classical Bound"},{"location":"Theory_for_Incompatible_Measurement_Test.html#quantum-violation","text":"Quantum mechanics can violate the discussed Bell inequality using the following protocol. This protocol was computed using the BellScenario.jl julia package to optimize the quantum violation using semi-definite programming. Alice encodes the input x x into a BB84 qubit state |\\psi_x\\rangle |\\psi_x\\rangle where |\\psi_0\\rangle = |0\\rangle |\\psi_0\\rangle = |0\\rangle , |\\psi_1\\rangle =|1\\rangle |\\psi_1\\rangle =|1\\rangle , |\\psi_2\\rangle = |+\\rangle |\\psi_2\\rangle = |+\\rangle , |\\psi_3\\rangle = |-\\rangle |\\psi_3\\rangle = |-\\rangle . Bob measures with a projective measurement onto a basis rotated off the BB84 states by an angle \\theta=\\pi/4 \\theta=\\pi/4 . The measurement bases for each input y y are expressed \\begin{align} &|\\Pi_0^{y=0}\\rangle = \\cos(\\pi/8)|0\\rangle + \\sin(\\pi/8)|1\\rangle, \\quad |\\Pi_1^{y=0}\\rangle = \\sin(\\pi/8)|0\\rangle - \\cos(\\pi/8)|1\\rangle \\\\ &|\\Pi_0^{y=1}\\rangle = \\cos(3\\pi/8)|0\\rangle + \\sin(3\\pi/8)|1\\rangle, \\quad |\\Pi_1^{y=1}\\rangle = \\sin(3\\pi/8)|0\\rangle - \\cos(3\\pi/8)|1\\rangle \\\\ \\end{align} \\begin{align} &|\\Pi_0^{y=0}\\rangle = \\cos(\\pi/8)|0\\rangle + \\sin(\\pi/8)|1\\rangle, \\quad |\\Pi_1^{y=0}\\rangle = \\sin(\\pi/8)|0\\rangle - \\cos(\\pi/8)|1\\rangle \\\\ &|\\Pi_0^{y=1}\\rangle = \\cos(3\\pi/8)|0\\rangle + \\sin(3\\pi/8)|1\\rangle, \\quad |\\Pi_1^{y=1}\\rangle = \\sin(3\\pi/8)|0\\rangle - \\cos(3\\pi/8)|1\\rangle \\\\ \\end{align} Since the quantum states consist of |0/1\\rangle |0/1\\rangle and |+/-\\rangle |+/-\\rangle bases, they require superposition to construct. Likewise, the quantum measurements are incompatible because the two measurement sets align with rotated |0/1\\rangle |0/1\\rangle and |+/-\\rangle |+/-\\rangle bases and therefore do not commute. On Bloch sphere, the states and measurements lie within the x x - z z -plane and take the following orientation. The conditional probabilities of each outcome are computed through the inner product, p(b|xy) = |\\langle\\Pi_b^y|\\psi_x\\rangle|^2 = \\cos^2(\\phi/2) p(b|xy) = |\\langle\\Pi_b^y|\\psi_x\\rangle|^2 = \\cos^2(\\phi/2) , where \\phi \\phi is the angle of separation between |\\psi_x\\rangle |\\psi_x\\rangle , and |\\Pi_b^y\\rangle |\\Pi_b^y\\rangle on Bloch sphere. By the symmetry of the BB84 states \\phi \\phi can be one of two values \\pi/4 \\pi/4 or 3\\pi/4 3\\pi/4 , therefore, p(b|xy)\\in \\{\\cos^2(\\pi/8),\\cos^2(3\\pi/8)\\} p(b|xy)\\in \\{\\cos^2(\\pi/8),\\cos^2(3\\pi/8)\\} . Computing the conditional probabilities for the classical bound, it is found that each of the probabilities in the inequality take on the value p(b|xy) = \\cos^2(\\pi/8) p(b|xy) = \\cos^2(\\pi/8) . Summing up all of the conditional probabilities in the inequality, a violation is found, 8\\cos^2(\\pi/8) = 6.818 \\nleq 6. 8\\cos^2(\\pi/8) = 6.818 \\nleq 6. The protocol violates the classical bound by 13.6\\% 13.6\\% . The quantum violation occurs with a single qubit. There is no entanglement, only superposition and measurement incompatibility.","title":"Quantum Violation"},{"location":"Theory_for_Incompatible_Measurement_Test.html#analyzing-the-quantum-violation","text":"This analysis shows: The quantum protocol violates and is optimal with respect to rotation of measurments. Violation does not occur if compatible measurments are used on the BB84 states. Violation does not occur if classical states are used with incompatible measurements. It can be concluded that superposition and measurement incompatibility are both required for a violation to occur in this protocol. The case of classical states and compatible measurements is not considered because such a scenario would be classical and would therefore be bounded by the derived Bell inequality.","title":"Analyzing the Quantum Violation"},{"location":"Theory_for_Incompatible_Measurement_Test.html#setup","text":"# imports % matplotlib inline import matplotlib.pyplot as plt import numpy as np import context from device_independent_test import incompatible_measurement","title":"Setup"},{"location":"Theory_for_Incompatible_Measurement_Test.html#quantum-states","text":"We first define Alice's qubits. The BB84 states are are encoded as \\{|0\\rangle, |1\\rangle, |+\\rangle, |-\\rangle\\} \\{|0\\rangle, |1\\rangle, |+\\rangle, |-\\rangle\\} , and the classical states are encoded as \\{|0\\rangle, |1\\rangle, |0\\rangle, |1\\rangle\\} \\{|0\\rangle, |1\\rangle, |0\\rangle, |1\\rangle\\} . We note that the the classical states will achieve the classical bound if measured in the computational basis. # qubit states \u03c8 0 = [ 1 , 0 ] \u03c8 1 = [ 0 , 1 ] \u03c8 2 = [ 1 , 1 ] / np . sqrt ( 2 ) \u03c8 3 = [ 1 , - 1 ] / np . sqrt ( 2 ) # quantum state encodings \u03c8 _bb84 = [ \u03c8 0 , \u03c8 1 , \u03c8 2 , \u03c8 3 ] \u03c8 _classical = [ \u03c8 0 , \u03c8 1 , \u03c8 0 , \u03c8 1 ]","title":"Quantum States"},{"location":"Theory_for_Incompatible_Measurement_Test.html#quantum-measurements","text":"We define Bob's measurements as two pairs of projective measurements. Each measurement has two outputs specified by b b and each measurement is used conditionally based on Bob's input y y . We wish to see how these quantum stategies perform against misalignment of devices so we will scan the measurements over an angle \\theta \\theta . # projective measurements \u03a0by \u03a0 00 = lambda \u03b8 : [ np . cos ( \u03b8 ), np . sin ( \u03b8 )] \u03a0 10 = lambda \u03b8 : [ np . sin ( \u03b8 ), - np . cos ( \u03b8 )] \u03a0 01 = lambda \u03b8 : [ np . cos ( \u03b8 + np . pi / 4 ), np . sin ( \u03b8 + np . pi / 4 )] \u03a0 11 = lambda \u03b8 : [ np . sin ( \u03b8 + np . pi / 4 ), - np . cos ( \u03b8 + np . pi / 4 )] # incompatible projective measurments y0_\u03a0 = [ \u03a0 00 , \u03a0 10 ] y1_\u03a0 = [ \u03a0 01 , \u03a0 11 ] # measurement compatible with y0_\u03a0 y1_cl_\u03a0 = [ \u03a0 10 , \u03a0 00 ]","title":"Quantum Measurements"},{"location":"Theory_for_Incompatible_Measurement_Test.html#calculating-performance-against-the-classical-bound","text":"We begin by defining some lists to collect data into: classical_bound = [] # bb84 states with in/compatible measurements bb84_incompatible_scores = [] bb84_compatible_scores = [] # classical states with incompatible measurements cl_incompatible_scores = [] We now compute the score against the Bell inequality for a range of rotation angles, \\theta \\in [0, \\pi/2] \\theta \\in [0, \\pi/2] . # Measurement angle on a hilbert space \u03b8 _series = np . arange ( 0 , np . pi / 2 , np . pi / 2048 ) # computing the bell scores as the measurements are rotated about the y-axis. for \u03b8 in \u03b8 _series : # conditional probability matrices y0_probs = np . zeros (( 2 , 4 )) y0_cl_probs = np . zeros (( 2 , 4 )) y1_probs = np . zeros (( 2 , 4 )) y1_cl_incomp_probs = np . zeros (( 2 , 4 )) y1_comp_probs = np . zeros (( 2 , 4 )) for x in range ( 0 , 4 ): \u03c8 x_bb84 = \u03c8 _bb84 [ x ] \u03c8 x_cl = \u03c8 _classical [ x ] for b in range ( 0 , 2 ): # y=0 measurement \u03a0 b0 = y0_\u03a0 [ b ] y0_probs [ b , x ] = np . inner ( \u03a0 b0 ( \u03b8 ), \u03c8 x_bb84 ) ** 2 y0_cl_probs [ b , x ] = np . inner ( \u03a0 b0 ( \u03b8 ), \u03c8 x_cl ) ** 2 # y=1 incompatible measurement \u03a0 b1 = y1_\u03a0 [ b ] y1_probs [ b , x ] = np . inner ( \u03a0 b1 ( \u03b8 ), \u03c8 x_bb84 ) ** 2 y1_cl_incomp_probs [ b , x ] = np . inner ( \u03a0 b1 ( \u03b8 ), \u03c8 x_cl ) ** 2 # y=1 compatible measurement \u03a0 b1_comp = y1_cl_\u03a0 [ b ] y1_comp_probs [ b , x ] = np . inner ( \u03a0 b1_comp ( \u03b8 ), \u03c8 x_bb84 ) ** 2 # aggregating scores into arrays of data bb84_incompatible_scores . append ( incompatible_measurement . bell_score ( y0_probs , y1_probs )) bb84_compatible_scores . append ( incompatible_measurement . bell_score ( y0_probs , y0_probs )) cl_incompatible_scores . append ( incompatible_measurement . bell_score ( y0_cl_probs , y1_cl_incomp_probs )) classical_bound . append ( 6 )","title":"Calculating Performance Against the Classical Bound"},{"location":"Theory_for_Incompatible_Measurement_Test.html#plot-of-violating-and-nonviolating-quantum-scenarios","text":"The discussed quantum protocol violates with the Max Quantum Violation of 6.818 6.818 . The Incompatible Measurements plot shows that if measurments are rotated in either direction, the violation decreases. This implies that the discussed protocol has been aligned in the optimal fashion. The Compatible Measurments plot shows that there is no rotation angle for which compatible measurements can violate the quantum bound. The conclusion is that superposition is necessary for this violation, but is not sufficient on its own. Measurment incompatiblity must also be applied. cl_bound_plt , = plt . plot ( \u03b8 _series , classical_bound , label = 'Classical Bound' ) # bb84 states incompatible measurments bb84_incomp_plt , = plt . plot ( \u03b8 _series , bb84_incompatible_scores , label = 'Incomp Measurment' , linestyle = '-.' ) # bb84 states compatible measurments bb84_comp_plt , = plt . plot ( \u03b8 _series , bb84_compatible_scores , label = \"Comp Measurement\" , linestyle = '--' ) # classical states incompatible measurements cl_incomp_plt , = plt . plot ( \u03b8 _series , cl_incompatible_scores , label = \"cl incomp\" , linestyle = \":\" ) max_violation , = plt . plot ( np . pi / 8 , 6.828 , 'ro' , label = \"Max Quantum Violation\" ) plt . legend ( [ max_violation , bb84_incomp_plt , cl_bound_plt , bb84_comp_plt , cl_incomp_plt ], [ 'Max Quantum Violation' , 'BB84 & Incompatible Measurements' , 'Classical Bound' , 'BB84 & Compatible Measurements' , 'Classical & Incompatible Measurements' ]) plt . xlabel ( \"Measurement Rotation Angle (radians)\" ) plt . ylabel ( \"Bell Score\" ) plt . title ( \"Quantum State Measurements vs. Angle\" );","title":"Plot of Violating and Nonviolating Quantum Scenarios"},{"location":"device_independent_handshake_protocol.html","text":"Device-Independent Handshake Protocol for Verifying Quantum Systems \u00b6 Test the quantum capabilities of unknown devices. This handshake protocol outlines a suite of tests to verify various quantum properties. The handshake is implemented by a verifier that wishes to verify an unknown device using a trusted device that is quantum enabled. If successful, our device-independent tests verify a minimal set of quantum technologies required for common quantum network protocols such as the BB84 quantum key distribution protocol or quantum teleportation. Our test suite is able to verify: Dimension of a quantum channel. Qubit superposition preparation. Qubit incompatible measurments. Bipartite entanglement. A successful handshake means that each quantum device can perform its advertised quantum properties and may be used to implement more sophisticated protocols such as quantum key distribution or teleportation. Setting \u00b6 We conisder a bipartite communication scenario involving two connected nodes in a quantum network. Each node has pre-established trust with a Verfier capable of performing a partial device-independent test . For convenience the test devices will be given labels Alice and Bob and their respective Verifiers will be labeled with \"A\" and \"B\" respectively. Device Verification Handshake Protocol \u00b6 Verifier A trusts device Alice and Verifier B trusts device Bob. Verifier A first uses its trust of Alice's quantum capabilities to certify Bob's quantum capabilities. Then Verifier B uses their trust of device B to certify Alice's quantum capabilities. If Alice and Bob verify each other to be quantum, then the handshake is successful and Alice and Bob may begin running more sophisticated quantum protocols. A Verifier tests Alice and Bob by running quantum protocols with measurement statistics designed to distinguish quantum systems from classical. The wavy line connecting Alice and Bob represents the quantum protocol they run to pass tests verify quantum capabilities. The described device independent tests can pass in two ways: Alice and Bob are both quantum-enabled and performed the task using quantum technology. Alice and Bob are conspiring to simulate quantum behavior without implementing authentic quantum technology. Assumptions \u00b6 Either Alice or Bob is trusted to perform their quantum tasks without error. A device is trusted if it is known to faithfully implement quantum instructions and functionality. Additionally, a trusted device has no hidden correlations or communication channels with other devices. Such hidden correlations would compromise the sanctity of a device-indpenendent test. Devices \u00b6 A Device is a black-box containing classical or quantum-enabled hardware. The responsibilities of a device include: Executing classical networking protocols to coordinate with other devices. Faithfully performing instructions passed through classical inputs. Reliably reporting outcomes through classical outptus. Accurately reporting its own quantum abilities and error rates. In practice, quantum devices could use different qubit implementations. It is important for a device to be able publicly share its communication medium. A quantum-enabled device may have various quantum abilities for example, Preparing superposition qubit states for quantum communication. Performing incompatible measurements on qubit states. Generating ebits or entangled 2-qubit states. Verifiers \u00b6 A Verifier is a classical device that referees device-independent tests. The Verifier's responsibilities include: Dispatching instructions to test devices. Analyzing outcome statistics to determine quantum properties. The dispatched instructions can be understood as quantum circuits to be run on the independent test devices. While running the device independent test, the instructions are drawn randomly froma finite set of possible circuits. The dispatched instructions can be considered inputs x x and y y within the black-box theory of device independent tests. The Verifier dispatches independent instructions to Alice and Bob and due to the randomness, Alice and Bob are unable to guess the others instruction with any uncertainty. Furthermore, test devices Alice and Bob are not required to know which test they are performing as the Verifier manages the test and the instructions which must be run. Tests \u00b6 Dimensionality \u00b6 Classical Dimension \u00b6 Objective: verify the minimal dimension, d d , of the quantum communication hilbert space. Setting: Alice receives an input x\\in\\{0,1,\\dots,(N-1) \\} x\\in\\{0,1,\\dots,(N-1) \\} and Bob has an output b\\in\\{0,1,\\dots,(N-1)\\} b\\in\\{0,1,\\dots,(N-1)\\} . N N is the hilbert space dimension which is being tested, e.g. N=2 N=2 for qubit classical dimension test. Input instructions x x are drawn from a uniform random distribution. Protocol: Alice receives input instructions x x which encode x x into computational basis states on a d d -dimension hilbert space. Alice sends the prepared computational basis state to Bob. Bob measures the state in the computational basis and outputs the result to the Verifier. The Verifier computes the success probability of the test p_{\\text{succ}} = \\frac{1}{N} \\sum_{x=0}^{N-1} p(b=x|x) p_{\\text{succ}} = \\frac{1}{N} \\sum_{x=0}^{N-1} p(b=x|x) . The success probability is bounded by the hilber space dimension d d , that is, 1 \\geq \\frac{d}{N} \\geq p_{\\text{succ}} \\geq 0 1 \\geq \\frac{d}{N} \\geq p_{\\text{succ}} \\geq 0 . Therefore, the test passes when p_{\\text{succ}} = 1 p_{\\text{succ}} = 1 because d=N d=N with certainty. Otherwise, the test will fail because the hilbert space dimension is not large enough to encode each input into an orthogonal state, \\frac{d}{N} \\geq p_{\\text{succ}} \\frac{d}{N} \\geq p_{\\text{succ}} . The test identifies the hilbert space dimension d d of a quantum state by running the test with N=d N=d . If the test passes, the hilbert space must have N N dimensions and therefore \\log_2(N) \\log_2(N) -qubits. Superposition & Measurement Incompatibility \u00b6 Single-Qubit Bell Violation \u00b6 Objective: verify the ability to prepare a superposition state on a qubit and perform incompatible measurments on the qubit state. Setting: Alice receives an input x\\in\\{0,1,2,3\\} x\\in\\{0,1,2,3\\} , Bob receives an input y\\in\\{0,1\\} y\\in\\{0,1\\} , and Bob outputs b\\in \\{0,1 \\} b\\in \\{0,1 \\} . Protocol: Alice receives input x x and encodes it into the BB84 qubit states \\{|0\\rangle, |1\\rangle, |+\\rangle,|-\\rangle\\} \\{|0\\rangle, |1\\rangle, |+\\rangle,|-\\rangle\\} . Alice sends the qubit to Bob. Bob measures with similar projective measurements rotated about the y y -axis by a Bloch angle of \\pi/4 \\pi/4 . If y=0 y=0 , Bob measures with \\{R_y(\\frac{\\pi}{4})|0\\rangle, R_y(\\frac{\\pi}{4})|1\\rangle\\} \\{R_y(\\frac{\\pi}{4})|0\\rangle, R_y(\\frac{\\pi}{4})|1\\rangle\\} If y=1 y=1 , Bob measures with \\{R_y(\\frac{\\pi}{4})|+\\rangle, R_y(\\frac{\\pi}{4})|-\\rangle \\} \\{R_y(\\frac{\\pi}{4})|+\\rangle, R_y(\\frac{\\pi}{4})|-\\rangle \\} Bob outputs measurement result b b to the Verifier. Success Requirement: Violation of single-qubit Bell inequaltiy. The test passes if Alice and Bob's statistics violate the Bell inequality described in the Measurement Incompatibility Theory section. The optimal classical score of the single-qubit Bell violation is 6, however, quantum mechanics can achieve 6.828 if they employ the described procedure. Since this test uses a Bell violation, it can be run in an ideal device-independent setting. If the assumption that only 1-qubit is sent between Alice and Bob holds, the Verifier does not need to trust Alice or Bob to determine that the system is quantum. Entanglement \u00b6 CHSH Bell Violation \u00b6 Objective: verify bipartite entanglement between two devices. Setting: Alice and Bob share a maximally entangled state and have no communication throughout a round of the test. The Verifier distributes input instructions x \\in \\{0,1\\} x \\in \\{0,1\\} to Alice and y\\in\\{0,1\\} y\\in\\{0,1\\} to Bob, who responds with classical outputs a\\in\\{0,1\\} a\\in\\{0,1\\} and b\\in\\{0,1\\} b\\in\\{0,1\\} . Protocol: Devices Alice and Bob receive measurement instructions x,y \\in \\{0,1\\} x,y \\in \\{0,1\\} . They perform the prescribed measurement on their shared entangled state. They report the binary measurement outcome to the Verifier a,b\\in \\{0,1\\} a,b\\in \\{0,1\\} Success Requirements: Violation of bipartite CHSH Bell inequality. The CHSH inequality bounds the classical correlation between the outputs of Alice and Bob. Quantum mechanics can violate the CHSH inequality by performing a set of incompatible measurements on entangled qubits. The best classical score is 2 2 while quantum mechanics can achieve 2\\sqrt{2} 2\\sqrt{2} against the CHSH inequality. If the no-signaling condition can be proven true, the Bell violation can be used as an ideal device-independent test to verify the presence of quantum technology in two unknown devices. Verifying the IBM Quantum Computer \u00b6 We have prototyped the device verification test suite on the IBM quantum computer. The results are reported in the Qiskit Examples page of this website. Our tests should be considered simulations of bipartite quantum communication scenarios, not legitimate verification of quantum behavior. The reason being that Alice and Bob's instructions are executed as part of the same circuit on the same device. This enables classical simulation to suffice for passing the tests as demonstrated by the the Qiskit simulator. As an implementation note, the tests on the IBM quantum computer were not run with random inputs. In a real-world scenario, this might allow a classical device to improve its success against a quantum test. However, we trust that the IBM quantum computers faithfully execute their instructions for each shot independently from previous shots. Therefore, randomizing the inputs should not have a meaningful effect on the test performance. Security \u00b6 Potential Exploits \u00b6 Our test suite could be exploited by classical simulations of quantum mechanics. The objective of the attacker might be to verify itself as quantum so that it becomes trusted to implement quantum cryptographic protocols with other devices. From this point, an attacker might be able to steal information being transmitted by authentic quantum devices. An unknown device Bob could implement this attack in the following manner: Bob intercepts all messages from Verifier A to Alice. Bob uses the knowledge of all input instructions coming from Verifier A. Bob uses knowledge of the inputs to simulate the statistics signature of the implemented test. Verfier A does not know that device Alice has been compromised and trusts Bob as a quantum-enabled device. Now that Verifier A trusts Bob as a quantum device, it may use Bob for cryptographic protocols such as key distribution. It is a simple task for Bob to continue simulating quantum protocols while copying all the classical information being passed. Such an attack is the exact reason why trust needs to be established between Alice and Verifier A (or Bob and Verifier B). This exploit can be negated by employing an ideal device independent test. This would require physicsal limitations to be placed on the amount of communication between Alice and Bob. For example, a CHSH violation requires that Alice and Bob do not communicate. This restriction can be met provided that Alice and Bob are separated by distances a large distance such that light cannot travel from one device to other within the scope of the test. Likewise, the single-qubit Bell violation used for our measurement incompatibility test requires that no more than one bit or qubit is shared between Alice and Bob. For an ideal device-independent implementation, the test could be performed at high-frequency baud rates such that the channels are operating at their maximum capacity. At high-frequency operation, it would be difficult to perform a classical simulation without sophisticated high-precision classical communication hardware. Classical Network Security \u00b6 The classical network communications used for coordinating tests between quantum devices should use state-of-the-art security standards for authenticating and securing communication with remote parties. The developed test suite does not guarantee security, however, it helps verify that more sophisticated cryptographic protocols may be implemented.","title":"Verification Protocol"},{"location":"device_independent_handshake_protocol.html#device-independent-handshake-protocol-for-verifying-quantum-systems","text":"Test the quantum capabilities of unknown devices. This handshake protocol outlines a suite of tests to verify various quantum properties. The handshake is implemented by a verifier that wishes to verify an unknown device using a trusted device that is quantum enabled. If successful, our device-independent tests verify a minimal set of quantum technologies required for common quantum network protocols such as the BB84 quantum key distribution protocol or quantum teleportation. Our test suite is able to verify: Dimension of a quantum channel. Qubit superposition preparation. Qubit incompatible measurments. Bipartite entanglement. A successful handshake means that each quantum device can perform its advertised quantum properties and may be used to implement more sophisticated protocols such as quantum key distribution or teleportation.","title":"Device-Independent Handshake Protocol for Verifying Quantum Systems"},{"location":"device_independent_handshake_protocol.html#setting","text":"We conisder a bipartite communication scenario involving two connected nodes in a quantum network. Each node has pre-established trust with a Verfier capable of performing a partial device-independent test . For convenience the test devices will be given labels Alice and Bob and their respective Verifiers will be labeled with \"A\" and \"B\" respectively.","title":"Setting"},{"location":"device_independent_handshake_protocol.html#device-verification-handshake-protocol","text":"Verifier A trusts device Alice and Verifier B trusts device Bob. Verifier A first uses its trust of Alice's quantum capabilities to certify Bob's quantum capabilities. Then Verifier B uses their trust of device B to certify Alice's quantum capabilities. If Alice and Bob verify each other to be quantum, then the handshake is successful and Alice and Bob may begin running more sophisticated quantum protocols. A Verifier tests Alice and Bob by running quantum protocols with measurement statistics designed to distinguish quantum systems from classical. The wavy line connecting Alice and Bob represents the quantum protocol they run to pass tests verify quantum capabilities. The described device independent tests can pass in two ways: Alice and Bob are both quantum-enabled and performed the task using quantum technology. Alice and Bob are conspiring to simulate quantum behavior without implementing authentic quantum technology.","title":"Device Verification Handshake Protocol"},{"location":"device_independent_handshake_protocol.html#assumptions","text":"Either Alice or Bob is trusted to perform their quantum tasks without error. A device is trusted if it is known to faithfully implement quantum instructions and functionality. Additionally, a trusted device has no hidden correlations or communication channels with other devices. Such hidden correlations would compromise the sanctity of a device-indpenendent test.","title":"Assumptions"},{"location":"device_independent_handshake_protocol.html#devices","text":"A Device is a black-box containing classical or quantum-enabled hardware. The responsibilities of a device include: Executing classical networking protocols to coordinate with other devices. Faithfully performing instructions passed through classical inputs. Reliably reporting outcomes through classical outptus. Accurately reporting its own quantum abilities and error rates. In practice, quantum devices could use different qubit implementations. It is important for a device to be able publicly share its communication medium. A quantum-enabled device may have various quantum abilities for example, Preparing superposition qubit states for quantum communication. Performing incompatible measurements on qubit states. Generating ebits or entangled 2-qubit states.","title":"Devices"},{"location":"device_independent_handshake_protocol.html#verifiers","text":"A Verifier is a classical device that referees device-independent tests. The Verifier's responsibilities include: Dispatching instructions to test devices. Analyzing outcome statistics to determine quantum properties. The dispatched instructions can be understood as quantum circuits to be run on the independent test devices. While running the device independent test, the instructions are drawn randomly froma finite set of possible circuits. The dispatched instructions can be considered inputs x x and y y within the black-box theory of device independent tests. The Verifier dispatches independent instructions to Alice and Bob and due to the randomness, Alice and Bob are unable to guess the others instruction with any uncertainty. Furthermore, test devices Alice and Bob are not required to know which test they are performing as the Verifier manages the test and the instructions which must be run.","title":"Verifiers"},{"location":"device_independent_handshake_protocol.html#tests","text":"","title":"Tests"},{"location":"device_independent_handshake_protocol.html#dimensionality","text":"","title":"Dimensionality"},{"location":"device_independent_handshake_protocol.html#classical-dimension","text":"Objective: verify the minimal dimension, d d , of the quantum communication hilbert space. Setting: Alice receives an input x\\in\\{0,1,\\dots,(N-1) \\} x\\in\\{0,1,\\dots,(N-1) \\} and Bob has an output b\\in\\{0,1,\\dots,(N-1)\\} b\\in\\{0,1,\\dots,(N-1)\\} . N N is the hilbert space dimension which is being tested, e.g. N=2 N=2 for qubit classical dimension test. Input instructions x x are drawn from a uniform random distribution. Protocol: Alice receives input instructions x x which encode x x into computational basis states on a d d -dimension hilbert space. Alice sends the prepared computational basis state to Bob. Bob measures the state in the computational basis and outputs the result to the Verifier. The Verifier computes the success probability of the test p_{\\text{succ}} = \\frac{1}{N} \\sum_{x=0}^{N-1} p(b=x|x) p_{\\text{succ}} = \\frac{1}{N} \\sum_{x=0}^{N-1} p(b=x|x) . The success probability is bounded by the hilber space dimension d d , that is, 1 \\geq \\frac{d}{N} \\geq p_{\\text{succ}} \\geq 0 1 \\geq \\frac{d}{N} \\geq p_{\\text{succ}} \\geq 0 . Therefore, the test passes when p_{\\text{succ}} = 1 p_{\\text{succ}} = 1 because d=N d=N with certainty. Otherwise, the test will fail because the hilbert space dimension is not large enough to encode each input into an orthogonal state, \\frac{d}{N} \\geq p_{\\text{succ}} \\frac{d}{N} \\geq p_{\\text{succ}} . The test identifies the hilbert space dimension d d of a quantum state by running the test with N=d N=d . If the test passes, the hilbert space must have N N dimensions and therefore \\log_2(N) \\log_2(N) -qubits.","title":"Classical Dimension"},{"location":"device_independent_handshake_protocol.html#superposition-measurement-incompatibility","text":"","title":"Superposition &amp; Measurement Incompatibility"},{"location":"device_independent_handshake_protocol.html#single-qubit-bell-violation","text":"Objective: verify the ability to prepare a superposition state on a qubit and perform incompatible measurments on the qubit state. Setting: Alice receives an input x\\in\\{0,1,2,3\\} x\\in\\{0,1,2,3\\} , Bob receives an input y\\in\\{0,1\\} y\\in\\{0,1\\} , and Bob outputs b\\in \\{0,1 \\} b\\in \\{0,1 \\} . Protocol: Alice receives input x x and encodes it into the BB84 qubit states \\{|0\\rangle, |1\\rangle, |+\\rangle,|-\\rangle\\} \\{|0\\rangle, |1\\rangle, |+\\rangle,|-\\rangle\\} . Alice sends the qubit to Bob. Bob measures with similar projective measurements rotated about the y y -axis by a Bloch angle of \\pi/4 \\pi/4 . If y=0 y=0 , Bob measures with \\{R_y(\\frac{\\pi}{4})|0\\rangle, R_y(\\frac{\\pi}{4})|1\\rangle\\} \\{R_y(\\frac{\\pi}{4})|0\\rangle, R_y(\\frac{\\pi}{4})|1\\rangle\\} If y=1 y=1 , Bob measures with \\{R_y(\\frac{\\pi}{4})|+\\rangle, R_y(\\frac{\\pi}{4})|-\\rangle \\} \\{R_y(\\frac{\\pi}{4})|+\\rangle, R_y(\\frac{\\pi}{4})|-\\rangle \\} Bob outputs measurement result b b to the Verifier. Success Requirement: Violation of single-qubit Bell inequaltiy. The test passes if Alice and Bob's statistics violate the Bell inequality described in the Measurement Incompatibility Theory section. The optimal classical score of the single-qubit Bell violation is 6, however, quantum mechanics can achieve 6.828 if they employ the described procedure. Since this test uses a Bell violation, it can be run in an ideal device-independent setting. If the assumption that only 1-qubit is sent between Alice and Bob holds, the Verifier does not need to trust Alice or Bob to determine that the system is quantum.","title":"Single-Qubit Bell Violation"},{"location":"device_independent_handshake_protocol.html#entanglement","text":"","title":"Entanglement"},{"location":"device_independent_handshake_protocol.html#chsh-bell-violation","text":"Objective: verify bipartite entanglement between two devices. Setting: Alice and Bob share a maximally entangled state and have no communication throughout a round of the test. The Verifier distributes input instructions x \\in \\{0,1\\} x \\in \\{0,1\\} to Alice and y\\in\\{0,1\\} y\\in\\{0,1\\} to Bob, who responds with classical outputs a\\in\\{0,1\\} a\\in\\{0,1\\} and b\\in\\{0,1\\} b\\in\\{0,1\\} . Protocol: Devices Alice and Bob receive measurement instructions x,y \\in \\{0,1\\} x,y \\in \\{0,1\\} . They perform the prescribed measurement on their shared entangled state. They report the binary measurement outcome to the Verifier a,b\\in \\{0,1\\} a,b\\in \\{0,1\\} Success Requirements: Violation of bipartite CHSH Bell inequality. The CHSH inequality bounds the classical correlation between the outputs of Alice and Bob. Quantum mechanics can violate the CHSH inequality by performing a set of incompatible measurements on entangled qubits. The best classical score is 2 2 while quantum mechanics can achieve 2\\sqrt{2} 2\\sqrt{2} against the CHSH inequality. If the no-signaling condition can be proven true, the Bell violation can be used as an ideal device-independent test to verify the presence of quantum technology in two unknown devices.","title":"CHSH Bell Violation"},{"location":"device_independent_handshake_protocol.html#verifying-the-ibm-quantum-computer","text":"We have prototyped the device verification test suite on the IBM quantum computer. The results are reported in the Qiskit Examples page of this website. Our tests should be considered simulations of bipartite quantum communication scenarios, not legitimate verification of quantum behavior. The reason being that Alice and Bob's instructions are executed as part of the same circuit on the same device. This enables classical simulation to suffice for passing the tests as demonstrated by the the Qiskit simulator. As an implementation note, the tests on the IBM quantum computer were not run with random inputs. In a real-world scenario, this might allow a classical device to improve its success against a quantum test. However, we trust that the IBM quantum computers faithfully execute their instructions for each shot independently from previous shots. Therefore, randomizing the inputs should not have a meaningful effect on the test performance.","title":"Verifying the IBM Quantum Computer"},{"location":"device_independent_handshake_protocol.html#security","text":"","title":"Security"},{"location":"device_independent_handshake_protocol.html#potential-exploits","text":"Our test suite could be exploited by classical simulations of quantum mechanics. The objective of the attacker might be to verify itself as quantum so that it becomes trusted to implement quantum cryptographic protocols with other devices. From this point, an attacker might be able to steal information being transmitted by authentic quantum devices. An unknown device Bob could implement this attack in the following manner: Bob intercepts all messages from Verifier A to Alice. Bob uses the knowledge of all input instructions coming from Verifier A. Bob uses knowledge of the inputs to simulate the statistics signature of the implemented test. Verfier A does not know that device Alice has been compromised and trusts Bob as a quantum-enabled device. Now that Verifier A trusts Bob as a quantum device, it may use Bob for cryptographic protocols such as key distribution. It is a simple task for Bob to continue simulating quantum protocols while copying all the classical information being passed. Such an attack is the exact reason why trust needs to be established between Alice and Verifier A (or Bob and Verifier B). This exploit can be negated by employing an ideal device independent test. This would require physicsal limitations to be placed on the amount of communication between Alice and Bob. For example, a CHSH violation requires that Alice and Bob do not communicate. This restriction can be met provided that Alice and Bob are separated by distances a large distance such that light cannot travel from one device to other within the scope of the test. Likewise, the single-qubit Bell violation used for our measurement incompatibility test requires that no more than one bit or qubit is shared between Alice and Bob. For an ideal device-independent implementation, the test could be performed at high-frequency baud rates such that the channels are operating at their maximum capacity. At high-frequency operation, it would be difficult to perform a classical simulation without sophisticated high-precision classical communication hardware.","title":"Potential Exploits"},{"location":"device_independent_handshake_protocol.html#classical-network-security","text":"The classical network communications used for coordinating tests between quantum devices should use state-of-the-art security standards for authenticating and securing communication with remote parties. The developed test suite does not guarantee security, however, it helps verify that more sophisticated cryptographic protocols may be implemented.","title":"Classical Network Security"},{"location":"theory_device_independent_tests.html","text":"Device-Independent Tests \u00b6 A device is a black-box system which performs some function or operation. The physical implementation inside the black-box could be classical, quantum, or even super-quantum, however it remains hidden and the focus of the test. Quantum communication protocols require devices to perform a number of basic quantum function such as preparing quantum superpositions, measuring with incompatible projectors, and creating entanglement. Ideal Device-Independent Tests \u00b6 A trusted Verifier tests two unknown devices labeled Alice and Bob. A test runs many rounds of the following protocol: The Verifier sends Alice and Bob indpendent random inputs x x and y y respectively. Alice and Bob perform a pre-specified task that transforms inputs x x and y y into discrete outputs a a and b b respectively. The Verifier records a a and b b and repeats the test. After many rounds have been run, the Verifier can construct a joint probability distribution for the devices p(a,b|x,y) p(a,b|x,y) . In nature, bounds known as Bell inequalities exist on the classical joint probability distributions. In certain scenarios, it is known that quantum resources facilitate the violation of Bell inequalities [1]. Test Assumptions \u00b6 Inputs x x and y y are sampled from independent random distributions and are private to each party. The prior distributions of inputs are uniform and known to all parties. Alice and Bob have limited communication resources. Communication Resources \u00b6 Each test uniquely specifies the allowed communication resources and their limitations. The communication resources are ordered from strongest to weakest [2] Quantum Communication: quantum states ( qubits ) Classical Communication: classical states ( cbits ) Quantum Entanglement: bipartite entanglement ( ebits ) Shared Randomness: public coin flips Local Randomness: private coin flips Simulating Quantum Systems with Classical Protocols \u00b6 Clasical simulations exist for communication resources: Bipartite entanglement correlations can be simulated using shared randomness and 1- cbit [3]. Quantum communication with 1- qubit can be simulated with 2- cbits and 1- ebit [2]. Therefore, it is essential for a device-independent test to place restrictions on the communication resources used. Communication Security and Classical Simulations \u00b6 One of the key advantages of quantum communication is cryptography. However, secure quantum protocols rely on devices which are truly quantum to perform the protocols. If a classical pair of devices is able to simulate a quantum system, the Verifier may be fooled into thinking that devices Alice and Bob are capable of securely performing a quantum cryptography protocol. This misconception would put the verifier at risk of sharing private information with potentially malicious devices. Partial Device-Independent Tests \u00b6 In real-world scenarios, it is difficult to enforce communication limitations between parties. However, if one of the devices can be characterized and trusted, it can be used to ensure communication limitations. For such a scenario, the Verifier uses a trusted device to perform device-independent tests which can only pass if the unknown device faithfully performs its tasks. For example, in a test where a single photon is sent from Alice to Bob. If Alice (or Bob) can be trusted to send (or receive) a single photon, then the trusted device can ensure the sanctity of the test. If trust in the device is compromised then the test is no longer meaningful because communication restrictions may have been broken. This would allow for a classical system to simulate quantum device statistics giving parties with malicious intent access to further information exchange. A device-independent should only pass if both parties faithfully execute their tasks. It doesn't matter whether Alice or Bob is the trusted device because ensuring one party fulfills their duty is sufficient to deduce that the other party must have as well. A partial device-independent test allows for a single party to verify a unknown devices capabilities. It does not provide the unknown device with any trust because the verifier could be sharing Bob's secret inputs with Alice. The solution is for each devices to characterize the other. A Verifier which trusts Alice runs the handshake protocol to verify Bob's quantum capabilities. A Verifier which trusts Bob runs the handshake protocol to verify Alices' quantum capabilities. It is not advantageous to use the trust between Verifier and device to cheat at the test. The objective of running the test in the first place is to verify an unknown device. If the Verifier cheats, the sanctity of the test is diminished and removing any incentive for the Verifier to cheat. Device Trust Through Community Verification \u00b6 For a partial device-independent test to be meaningful, the Verifier must trust one of the devices involved. Gaining this trust is a difficult task, however, community-driven approach may be able to improve the trust of an unknown device. Community verificication could be implemented in the following way. In the setting of a quantum network, there will be many connected devices. To establish trust of a device's quantum capabilities, it is possible for a Verifier to use the untrusted device to run tests against a large number of devices. If the community of devices has a large number of quantum capable devices, it would be possible leverage the community to gain trust in an untrusted device. Furthermore, in a realistic setting, quantum devices used on a quantum network will be subject to standardization and regulation. This will provide unknown devices some merit of truth about their quantum capabalities. With a community verification system in place, a breach of network security would require the majority of devices to be compromised. These are hypothetical situations, but illustrate how community verification might be useful to gain basic trust of a device. References \u00b6 [1] Brunner, Nicolas, et al. \"Bell nonlocality.\" Reviews of Modern Physics 86.2 (2014): 419. [2] Buhrman, Harry, et al. \"Nonlocality and communication complexity.\" Reviews of modern physics 82.1 (2010): 665. [3] Toner, Benjamin F., and Dave Bacon. \"Communication cost of simulating Bell correlations.\" Physical Review Letters 91.18 (2003): 1879","title":"Device-Independent Tests"},{"location":"theory_device_independent_tests.html#device-independent-tests","text":"A device is a black-box system which performs some function or operation. The physical implementation inside the black-box could be classical, quantum, or even super-quantum, however it remains hidden and the focus of the test. Quantum communication protocols require devices to perform a number of basic quantum function such as preparing quantum superpositions, measuring with incompatible projectors, and creating entanglement.","title":"Device-Independent Tests"},{"location":"theory_device_independent_tests.html#ideal-device-independent-tests","text":"A trusted Verifier tests two unknown devices labeled Alice and Bob. A test runs many rounds of the following protocol: The Verifier sends Alice and Bob indpendent random inputs x x and y y respectively. Alice and Bob perform a pre-specified task that transforms inputs x x and y y into discrete outputs a a and b b respectively. The Verifier records a a and b b and repeats the test. After many rounds have been run, the Verifier can construct a joint probability distribution for the devices p(a,b|x,y) p(a,b|x,y) . In nature, bounds known as Bell inequalities exist on the classical joint probability distributions. In certain scenarios, it is known that quantum resources facilitate the violation of Bell inequalities [1].","title":"Ideal Device-Independent Tests"},{"location":"theory_device_independent_tests.html#test-assumptions","text":"Inputs x x and y y are sampled from independent random distributions and are private to each party. The prior distributions of inputs are uniform and known to all parties. Alice and Bob have limited communication resources.","title":"Test Assumptions"},{"location":"theory_device_independent_tests.html#communication-resources","text":"Each test uniquely specifies the allowed communication resources and their limitations. The communication resources are ordered from strongest to weakest [2] Quantum Communication: quantum states ( qubits ) Classical Communication: classical states ( cbits ) Quantum Entanglement: bipartite entanglement ( ebits ) Shared Randomness: public coin flips Local Randomness: private coin flips","title":"Communication Resources"},{"location":"theory_device_independent_tests.html#simulating-quantum-systems-with-classical-protocols","text":"Clasical simulations exist for communication resources: Bipartite entanglement correlations can be simulated using shared randomness and 1- cbit [3]. Quantum communication with 1- qubit can be simulated with 2- cbits and 1- ebit [2]. Therefore, it is essential for a device-independent test to place restrictions on the communication resources used.","title":"Simulating Quantum Systems with Classical Protocols"},{"location":"theory_device_independent_tests.html#communication-security-and-classical-simulations","text":"One of the key advantages of quantum communication is cryptography. However, secure quantum protocols rely on devices which are truly quantum to perform the protocols. If a classical pair of devices is able to simulate a quantum system, the Verifier may be fooled into thinking that devices Alice and Bob are capable of securely performing a quantum cryptography protocol. This misconception would put the verifier at risk of sharing private information with potentially malicious devices.","title":"Communication Security and Classical Simulations"},{"location":"theory_device_independent_tests.html#partial-device-independent-tests","text":"In real-world scenarios, it is difficult to enforce communication limitations between parties. However, if one of the devices can be characterized and trusted, it can be used to ensure communication limitations. For such a scenario, the Verifier uses a trusted device to perform device-independent tests which can only pass if the unknown device faithfully performs its tasks. For example, in a test where a single photon is sent from Alice to Bob. If Alice (or Bob) can be trusted to send (or receive) a single photon, then the trusted device can ensure the sanctity of the test. If trust in the device is compromised then the test is no longer meaningful because communication restrictions may have been broken. This would allow for a classical system to simulate quantum device statistics giving parties with malicious intent access to further information exchange. A device-independent should only pass if both parties faithfully execute their tasks. It doesn't matter whether Alice or Bob is the trusted device because ensuring one party fulfills their duty is sufficient to deduce that the other party must have as well. A partial device-independent test allows for a single party to verify a unknown devices capabilities. It does not provide the unknown device with any trust because the verifier could be sharing Bob's secret inputs with Alice. The solution is for each devices to characterize the other. A Verifier which trusts Alice runs the handshake protocol to verify Bob's quantum capabilities. A Verifier which trusts Bob runs the handshake protocol to verify Alices' quantum capabilities. It is not advantageous to use the trust between Verifier and device to cheat at the test. The objective of running the test in the first place is to verify an unknown device. If the Verifier cheats, the sanctity of the test is diminished and removing any incentive for the Verifier to cheat.","title":"Partial Device-Independent Tests"},{"location":"theory_device_independent_tests.html#device-trust-through-community-verification","text":"For a partial device-independent test to be meaningful, the Verifier must trust one of the devices involved. Gaining this trust is a difficult task, however, community-driven approach may be able to improve the trust of an unknown device. Community verificication could be implemented in the following way. In the setting of a quantum network, there will be many connected devices. To establish trust of a device's quantum capabilities, it is possible for a Verifier to use the untrusted device to run tests against a large number of devices. If the community of devices has a large number of quantum capable devices, it would be possible leverage the community to gain trust in an untrusted device. Furthermore, in a realistic setting, quantum devices used on a quantum network will be subject to standardization and regulation. This will provide unknown devices some merit of truth about their quantum capabalities. With a community verification system in place, a breach of network security would require the majority of devices to be compromised. These are hypothetical situations, but illustrate how community verification might be useful to gain basic trust of a device.","title":"Device Trust Through Community Verification"},{"location":"theory_device_independent_tests.html#references","text":"[1] Brunner, Nicolas, et al. \"Bell nonlocality.\" Reviews of Modern Physics 86.2 (2014): 419. [2] Buhrman, Harry, et al. \"Nonlocality and communication complexity.\" Reviews of modern physics 82.1 (2010): 665. [3] Toner, Benjamin F., and Dave Bacon. \"Communication cost of simulating Bell correlations.\" Physical Review Letters 91.18 (2003): 1879","title":"References"},{"location":"theory_dimensionality_tests.html","text":"Verifying Hilbert Space Dimension \u00b6","title":"Verifying Hilbert Space Dimension"},{"location":"theory_dimensionality_tests.html#verifying-hilbert-space-dimension","text":"","title":"Verifying Hilbert Space Dimension"},{"location":"when_tests_fail.html","text":"What Happens When the Wrong Operations are Performed? \u00b6 In our tests we trust the prepartory system (Alice). We assume Alice properly performs the correct operations and prepares the desired states. However, we do not claim to know if Bob can properly perform the required tests. What happens if Bob does not perform the correct operations? This document runs through examples of performing the wrong measurements and how our tests detect this. Dimensionality Testing \u00b6 Incompatible Measurement Testing \u00b6 This module determines if a quantum device can perform incompatible measurements. Recall that incompatible measurments are those which do not commute, measuring in the Z and X bases, for example. Below the compatible measurement from the theory notebook is performed. Bob's first (y=0) projective measurement performs the following rotation (the global phase on the second basis state has been changed): \\begin{pmatrix} cos(\\theta) & sin(\\theta)\\ -sin(\\theta) & cos(\\theta)\\ \\end{pmatrix} Thus we can perform Bob's measurement via a Y rotation by - 2\\theta 2\\theta then a measurment in the computational basis. Now let's construct the matrix for the compatible measurement. This is given by: \\begin{pmatrix} sin(\\theta + \\pi /4) & -cos(\\theta + \\pi /4)\\ cos(\\theta + \\pi /4) & sin(\\theta + \\pi /4)\\ \\end{pmatrix} Using a couple trig properties, this becomes \\begin{pmatrix} cos(\\pi /4 -\\theta) & -sin(\\pi /4 -\\theta)\\ sin(\\pi / 4 -\\theta) & cos(\\pi /4 -\\theta)\\ \\end{pmatrix} The above matrix is a rotation of 2(\\pi /4 -\\theta) 2(\\pi /4 -\\theta) around the Y axis. In the incompatible measurement test, we use \\theta = \\pi / 8 \\theta = \\pi / 8 . Thus, this measurement is achieved via a rotation of \\pi / 4 \\pi / 4 . The code snippet below implements this compatible measurement. This set of projective measurements should not violate the classical bounds. from qiskit import QuantumCircuit , IBMQ import numpy as np import context from device_independent_test import incompatible_measurement from device_independent_test import quantum_communicator provider = IBMQ . load_account () dispatch = quantum_communicator . LocalDispatcher ([ provider . get_backend ( 'ibmq_qasm_simulator' )]) # create bb84 states pre_ops = [ incompatible_measurement . bb84_states ()] # measure in the wrong basis qc0 = QuantumCircuit ( 4 ) qc0 . u3 ( - np . pi / 4 , 0 , 0 , range ( 0 , 4 )) qc0 . measure_all () qc1 = QuantumCircuit ( 4 ) qc1 . u3 ( np . pi / 4 , 0 , 0 , range ( 0 , 4 )) qc1 . measure_all () post_ops = [[ QuantumCircuit ( 4 )],[ qc0 , qc1 ]] counts = dispatch . batch_run_and_transmit ( pre_ops , post_ops , 1000 ) violation = incompatible_measurement . bell_violation ( counts [ 0 ], counts [ 1 ], 1000 , 1000 ) print ( violation ) ibmqfactory.load_account:WARNING:2020-06-29 13:26:31,632: Credentials are already in use. The existing account in the session will be replaced. 4.04 Entanglement Testing \u00b6 The CHSH test in this library truly relies both upon entanglement and incompatible measurments. For the purposes of this document, we will assume that the ability to perform incompatible measurments has already been verified. The code below demonstrates what happens if an entangled pair is not generated. The first code block demonstrates the value of the CHSH test for two randomly generated states. The second demonstrates the result of the CHSH test when the entangling CNOT fails with a set failure probability. from qiskit.quantum_info import random_unitary dispatch = quantum_communicator . LocalDispatcher ([ provider . get_backend ( 'ibmq_qasm_simulator' )]) shots = 1000 # Generate two random states via random unitary operations random_circ = random_unitary ( 2 ) . tensor ( random_unitary ( 2 )) qc = QuantumCircuit ( 2 ) qc . unitary ( random_circ ,[ 0 , 1 ], label = 'random unitaries' ) qc . draw () post_ops = [[ QuantumCircuit ( 2 )],[ entanglement . measure_in_ZW (), entanglement . measure_in_ZV (), entanglement . measure_in_XW (), entanglement . measure_in_XV ()]] counts = dispatch . batch_run_and_transmit ([ qc ], post_ops , shots ) expected_ZW = entanglement . compute_expectation_for_CHSH ( counts [ 0 ], shots ) expected_ZV = entanglement . compute_expectation_for_CHSH ( counts [ 1 ], shots ) expected_XW = entanglement . compute_expectation_for_CHSH ( counts [ 2 ], shots ) expected_XV = entanglement . compute_expectation_for_CHSH ( counts [ 3 ], shots ) test_val = ( expected_ZW + expected_ZV + expected_XW - expected_XV ) print ( test_val ) -0.10199999999999998 import context from device_independent_test import entanglement from random import random dispatch = quantum_communicator . LocalDispatcher ([ provider . get_backend ( 'ibmq_qasm_simulator' )]) shots = 200 runs = 5 p_failure = 0.2 post_ops = [[ QuantumCircuit ( 2 )],[ entanglement . measure_in_ZW (), entanglement . measure_in_ZV (), entanglement . measure_in_XW (), entanglement . measure_in_XV ()]] counts = [{ \"00\" : 0 , \"11\" : 0 , \"10\" : 0 , \"01\" : 0 },{ \"00\" : 0 , \"11\" : 0 , \"10\" : 0 , \"01\" : 0 },{ \"00\" : 0 , \"11\" : 0 , \"10\" : 0 , \"01\" : 0 },{ \"00\" : 0 , \"11\" : 0 , \"10\" : 0 , \"01\" : 0 }] for i in range ( 0 , runs ): qc = QuantumCircuit ( 2 ) qc . h ( 0 ) if random () > p_failure : qc . cx ( 0 , 1 ) temp = dispatch . batch_run_and_transmit ([ qc ], post_ops , shots ) for j in range ( 0 , 4 ): for key in counts [ j ]: counts [ j ][ key ] = counts [ j ][ key ] + temp [ j ] . get ( key , 0.0 ) expected_ZW = entanglement . compute_expectation_for_CHSH ( counts [ 0 ], shots * runs ) expected_ZV = entanglement . compute_expectation_for_CHSH ( counts [ 1 ], shots * runs ) expected_XW = entanglement . compute_expectation_for_CHSH ( counts [ 2 ], shots * runs ) expected_XV = entanglement . compute_expectation_for_CHSH ( counts [ 3 ], shots * runs ) test_val = ( expected_ZW + expected_ZV + expected_XW - expected_XV ) print ( test_val ) 2.846","title":"Validating Test Failures"},{"location":"when_tests_fail.html#what-happens-when-the-wrong-operations-are-performed","text":"In our tests we trust the prepartory system (Alice). We assume Alice properly performs the correct operations and prepares the desired states. However, we do not claim to know if Bob can properly perform the required tests. What happens if Bob does not perform the correct operations? This document runs through examples of performing the wrong measurements and how our tests detect this.","title":"What Happens When the Wrong Operations are Performed?"},{"location":"when_tests_fail.html#dimensionality-testing","text":"","title":"Dimensionality Testing"},{"location":"when_tests_fail.html#incompatible-measurement-testing","text":"This module determines if a quantum device can perform incompatible measurements. Recall that incompatible measurments are those which do not commute, measuring in the Z and X bases, for example. Below the compatible measurement from the theory notebook is performed. Bob's first (y=0) projective measurement performs the following rotation (the global phase on the second basis state has been changed): \\begin{pmatrix} cos(\\theta) & sin(\\theta)\\ -sin(\\theta) & cos(\\theta)\\ \\end{pmatrix} Thus we can perform Bob's measurement via a Y rotation by - 2\\theta 2\\theta then a measurment in the computational basis. Now let's construct the matrix for the compatible measurement. This is given by: \\begin{pmatrix} sin(\\theta + \\pi /4) & -cos(\\theta + \\pi /4)\\ cos(\\theta + \\pi /4) & sin(\\theta + \\pi /4)\\ \\end{pmatrix} Using a couple trig properties, this becomes \\begin{pmatrix} cos(\\pi /4 -\\theta) & -sin(\\pi /4 -\\theta)\\ sin(\\pi / 4 -\\theta) & cos(\\pi /4 -\\theta)\\ \\end{pmatrix} The above matrix is a rotation of 2(\\pi /4 -\\theta) 2(\\pi /4 -\\theta) around the Y axis. In the incompatible measurement test, we use \\theta = \\pi / 8 \\theta = \\pi / 8 . Thus, this measurement is achieved via a rotation of \\pi / 4 \\pi / 4 . The code snippet below implements this compatible measurement. This set of projective measurements should not violate the classical bounds. from qiskit import QuantumCircuit , IBMQ import numpy as np import context from device_independent_test import incompatible_measurement from device_independent_test import quantum_communicator provider = IBMQ . load_account () dispatch = quantum_communicator . LocalDispatcher ([ provider . get_backend ( 'ibmq_qasm_simulator' )]) # create bb84 states pre_ops = [ incompatible_measurement . bb84_states ()] # measure in the wrong basis qc0 = QuantumCircuit ( 4 ) qc0 . u3 ( - np . pi / 4 , 0 , 0 , range ( 0 , 4 )) qc0 . measure_all () qc1 = QuantumCircuit ( 4 ) qc1 . u3 ( np . pi / 4 , 0 , 0 , range ( 0 , 4 )) qc1 . measure_all () post_ops = [[ QuantumCircuit ( 4 )],[ qc0 , qc1 ]] counts = dispatch . batch_run_and_transmit ( pre_ops , post_ops , 1000 ) violation = incompatible_measurement . bell_violation ( counts [ 0 ], counts [ 1 ], 1000 , 1000 ) print ( violation ) ibmqfactory.load_account:WARNING:2020-06-29 13:26:31,632: Credentials are already in use. The existing account in the session will be replaced. 4.04","title":"Incompatible Measurement Testing"},{"location":"when_tests_fail.html#entanglement-testing","text":"The CHSH test in this library truly relies both upon entanglement and incompatible measurments. For the purposes of this document, we will assume that the ability to perform incompatible measurments has already been verified. The code below demonstrates what happens if an entangled pair is not generated. The first code block demonstrates the value of the CHSH test for two randomly generated states. The second demonstrates the result of the CHSH test when the entangling CNOT fails with a set failure probability. from qiskit.quantum_info import random_unitary dispatch = quantum_communicator . LocalDispatcher ([ provider . get_backend ( 'ibmq_qasm_simulator' )]) shots = 1000 # Generate two random states via random unitary operations random_circ = random_unitary ( 2 ) . tensor ( random_unitary ( 2 )) qc = QuantumCircuit ( 2 ) qc . unitary ( random_circ ,[ 0 , 1 ], label = 'random unitaries' ) qc . draw () post_ops = [[ QuantumCircuit ( 2 )],[ entanglement . measure_in_ZW (), entanglement . measure_in_ZV (), entanglement . measure_in_XW (), entanglement . measure_in_XV ()]] counts = dispatch . batch_run_and_transmit ([ qc ], post_ops , shots ) expected_ZW = entanglement . compute_expectation_for_CHSH ( counts [ 0 ], shots ) expected_ZV = entanglement . compute_expectation_for_CHSH ( counts [ 1 ], shots ) expected_XW = entanglement . compute_expectation_for_CHSH ( counts [ 2 ], shots ) expected_XV = entanglement . compute_expectation_for_CHSH ( counts [ 3 ], shots ) test_val = ( expected_ZW + expected_ZV + expected_XW - expected_XV ) print ( test_val ) -0.10199999999999998 import context from device_independent_test import entanglement from random import random dispatch = quantum_communicator . LocalDispatcher ([ provider . get_backend ( 'ibmq_qasm_simulator' )]) shots = 200 runs = 5 p_failure = 0.2 post_ops = [[ QuantumCircuit ( 2 )],[ entanglement . measure_in_ZW (), entanglement . measure_in_ZV (), entanglement . measure_in_XW (), entanglement . measure_in_XV ()]] counts = [{ \"00\" : 0 , \"11\" : 0 , \"10\" : 0 , \"01\" : 0 },{ \"00\" : 0 , \"11\" : 0 , \"10\" : 0 , \"01\" : 0 },{ \"00\" : 0 , \"11\" : 0 , \"10\" : 0 , \"01\" : 0 },{ \"00\" : 0 , \"11\" : 0 , \"10\" : 0 , \"01\" : 0 }] for i in range ( 0 , runs ): qc = QuantumCircuit ( 2 ) qc . h ( 0 ) if random () > p_failure : qc . cx ( 0 , 1 ) temp = dispatch . batch_run_and_transmit ([ qc ], post_ops , shots ) for j in range ( 0 , 4 ): for key in counts [ j ]: counts [ j ][ key ] = counts [ j ][ key ] + temp [ j ] . get ( key , 0.0 ) expected_ZW = entanglement . compute_expectation_for_CHSH ( counts [ 0 ], shots * runs ) expected_ZV = entanglement . compute_expectation_for_CHSH ( counts [ 1 ], shots * runs ) expected_XW = entanglement . compute_expectation_for_CHSH ( counts [ 2 ], shots * runs ) expected_XV = entanglement . compute_expectation_for_CHSH ( counts [ 3 ], shots * runs ) test_val = ( expected_ZW + expected_ZV + expected_XW - expected_XV ) print ( test_val ) 2.846","title":"Entanglement Testing"}]}