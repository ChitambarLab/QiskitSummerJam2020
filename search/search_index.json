{"config":{"lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"index.html","text":"Device-Independent Tests for Quantum Networks \u00b6","title":"Home"},{"location":"index.html#device-independent-tests-for-quantum-networks","text":"","title":"Device-Independent Tests for Quantum Networks"},{"location":"Entanglement.html","text":"Entanglement Testing \u00b6 # Importing standard Qiskit libraries and configuring account from qiskit import QuantumCircuit , execute , Aer , IBMQ from qiskit.compiler import transpile , assemble from qiskit.tools.jupyter import * from qiskit.visualization import * from qiskit.providers.ibmq.managed import IBMQJobManager # Loading your IBM Q account(s) import qiskit from qiskit import IBMQ import matplotlib.pyplot as plt import numpy as np from device_independent_test.entanglement import EntanglementTest test = EntanglementTest () test . run_CHSH_test ( backend = \"ibmq_qasm_simulator\" , shots = 3000 ) ibmqfactory.load_account:WARNING:2020-06-26 16:49:59,854: Credentials are already in use. The existing account in the session will be replaced. {'received': 2.844, 'expected': 2.8284271247461903}","title":"Entanglement"},{"location":"Entanglement.html#entanglement-testing","text":"# Importing standard Qiskit libraries and configuring account from qiskit import QuantumCircuit , execute , Aer , IBMQ from qiskit.compiler import transpile , assemble from qiskit.tools.jupyter import * from qiskit.visualization import * from qiskit.providers.ibmq.managed import IBMQJobManager # Loading your IBM Q account(s) import qiskit from qiskit import IBMQ import matplotlib.pyplot as plt import numpy as np from device_independent_test.entanglement import EntanglementTest test = EntanglementTest () test . run_CHSH_test ( backend = \"ibmq_qasm_simulator\" , shots = 3000 ) ibmqfactory.load_account:WARNING:2020-06-26 16:49:59,854: Credentials are already in use. The existing account in the session will be replaced. {'received': 2.844, 'expected': 2.8284271247461903}","title":"Entanglement Testing"},{"location":"Incompatible_Measurement.html","text":"Measurement Incompatibility Testing \u00b6 # Make sure to load your IBM Q token before running the below block # Importing standard Qiskit libraries and configuring account from qiskit import QuantumCircuit , execute , Aer , IBMQ from qiskit.compiler import transpile , assemble from qiskit.tools.jupyter import * from qiskit.visualization import * from qiskit.providers.ibmq.managed import IBMQJobManager # Loading your IBM Q account(s) provider = IBMQ . load_account () import matplotlib.pyplot as plt import numpy as np # custom code import context from device_independent_test import incompatible_measurement ibmqfactory.load_account:WARNING:2020-06-25 13:41:58,859: Credentials are already in use. The existing account in the session will be replaced. def bb84_states (): # Alice's half of the circuit # creates 0,1,+,- qc = QuantumCircuit ( 4 ) qc . x ( 1 ) # create 1 qc . h ( 2 ) # create + qc . x ( 3 ) # create - qc . h ( 3 ) # ^ return qc def measure_circuit ( y ): # Bob's measurement circuit # measure in either pi/4 or 3pi/4 basis assert y == 0 or y == 1 , \"Bob's input should be 0 or 1\" qc = QuantumCircuit ( 4 ) theta = - 1.0 * ( np . pi / 4 + 0.5 * y * np . pi ) qc . u3 ( theta , 0 , 0 , range ( 0 , 4 )) #qc.u3(theta,0,0,1) #qc.u3(theta,0,0,2) #qc.u3(theta,0,0,3) qc . measure_all () return qc qc = bb84_states () + measure_circuit ( 0 ) qc . draw () \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 \u2591 \u250c\u2500\u2510 q_0: \u2524 U3(-pi/4,0,0) \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2591\u2500\u2524M\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 \u2514\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2518\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 \u2591 \u2514\u2565\u2518\u250c\u2500\u2510 q_1: \u2500\u2500\u2500\u2500\u2500\u2500\u2524 X \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2524 U3(-pi/4,0,0) \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2591\u2500\u2500\u256b\u2500\u2524M\u251c\u2500\u2500\u2500\u2500\u2500\u2500 \u251c\u2500\u2500\u2500\u2524 \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524 \u2591 \u2551 \u2514\u2565\u2518\u250c\u2500\u2510 q_2: \u2500\u2500\u2500\u2500\u2500\u2500\u2524 H \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2524 U3(-pi/4,0,0) \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2591\u2500\u2500\u256b\u2500\u2500\u256b\u2500\u2524M\u251c\u2500\u2500\u2500 \u251c\u2500\u2500\u2500\u2524 \u2514\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2518\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 \u2591 \u2551 \u2551 \u2514\u2565\u2518\u250c\u2500\u2510 q_3: \u2500\u2500\u2500\u2500\u2500\u2500\u2524 X \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524 H \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2524 U3(-pi/4,0,0) \u251c\u2500\u2591\u2500\u2500\u256b\u2500\u2500\u256b\u2500\u2500\u256b\u2500\u2524M\u251c \u2514\u2500\u2500\u2500\u2518 \u2514\u2500\u2500\u2500\u2518 \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518 \u2591 \u2551 \u2551 \u2551 \u2514\u2565\u2518 meas_0: \u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2569\u2550\u2550\u256c\u2550\u2550\u256c\u2550\u2550\u256c\u2550 \u2551 \u2551 \u2551 meas_1: \u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2569\u2550\u2550\u256c\u2550\u2550\u256c\u2550 \u2551 \u2551 meas_2: \u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2569\u2550\u2550\u256c\u2550 \u2551 meas_3: \u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2569\u2550 # OUTDATED CODE # SEE CELL BELOW FOR BATCH JOB from qiskit.tools.monitor import * def run_job ( qc ): # runs test on all inputs # run cicuits in one batch #job_manager = IBMQJobManager() #job_set = job_manager.run([qc_0, qc_1], backend=provider.get_backend('ibmq_qasm_simulator'), name='msrincom_test') #job_monitor(job_set) #job_set.error_message() job = execute ( qc , backend = provider . get_backend ( 'ibmq_qasm_simulator' ), shots = 1000 ) job_monitor ( job ) return job qc_0 = bb84_states () + measure_circuit ( 0 ) job = run_job ( qc_0 ) job . result () . get_counts ( qc_0 ) plot_histogram ( job . result () . get_counts ( qc_0 )) Job Status: job has successfully run from qiskit.tools.monitor import * def run_jobs ( qc ): # run cicuits in one batch job_manager = IBMQJobManager () job_set = job_manager . run ( qc , backend = provider . get_backend ( 'ibmq_qasm_simulator' ), name = 'msrincom_test' ) job_set . error_messages () return job_set qc_0 = bb84_states () + measure_circuit ( 0 ) qc_1 = bb84_states () + measure_circuit ( 1 ) managed_job = run_jobs ([ qc_0 , qc_1 ]) result_0 = managed_job . job ( 0 )[ 0 ] . result () result_1 = managed_job . job ( 1 )[ 0 ] . result () #managed_job.job(0)[0].error_message() result_0 . get_counts ( qc_0 ) {'1011': 85, '0000': 17, '0001': 2, '1001': 23, '1111': 20, '1100': 18, '1010': 524, '0010': 104, '0100': 4, '0111': 3, '1101': 4, '0110': 10, '1110': 94, '1000': 105, '0011': 11} qc_1 = bb84_states () + measure_circuit ( 1 ) job2 = run_job ( qc_1 ) job2 . result () . get_counts ( qc_1 ) plot_histogram ( job2 . result () . get_counts ( qc_1 )) Job Status: job has successfully run counts = job2 . result () . get_counts ( qc_1 ) print ( counts ) # 2x4 matrix for probabilities # row for x # column for y bins = ( 2 , 4 ) bins = np . zeros ( bins ) # iterate over dictionary for state in counts : for i in range ( 0 , 4 ): r = int ( state [ i ]) c = 3 - i bins [ r , c ] += counts [ state ] print ( bins ) # convert bins to probibilities probs = bins / 1000.0 print ( probs ) {'1011': 78, '0000': 11, '0001': 103, '1001': 523, '1111': 17, '1100': 14, '0101': 19, '1010': 16, '0111': 3, '1101': 103, '0110': 1, '1110': 5, '1000': 91, '0011': 16} [[138. 864. 838. 153.] [862. 136. 162. 847.]] [[0.138 0.864 0.838 0.153] [0.862 0.136 0.162 0.847]] from qiskit.quantum_info import Statevector qc = bb84_states () state = Statevector . from_instruction ( qc ) print ( state ) real_state = [ 0 , 0 , 0.5 + 0.j , 0 , 0 , 0 , 0.5 , 0 , 0 , 0 , - 0.5 , 0 , 0 , 0 , - 0.5 , 0 ] print ( state . data ) print ( state . data == real_state ) print ( state . data [ 2 ]) error = abs ( state . data - real_state ) epsilon = 1.0E-4 any ( x > epsilon for x in error ) Statevector([ 0. +0.j, 0. +0.j, 0.5+0.j, 0. +0.j, 0. +0.j, 0. +0.j, 0.5+0.j, 0. +0.j, 0. +0.j, 0. +0.j, -0.5+0.j, 0. +0.j, 0. +0.j, 0. +0.j, -0.5+0.j, 0. +0.j], dims=(2, 2, 2, 2)) [ 0. +0.j 0. +0.j 0.5+0.j 0. +0.j 0. +0.j 0. +0.j 0.5+0.j 0. +0.j 0. +0.j 0. +0.j -0.5+0.j 0. +0.j 0. +0.j 0. +0.j -0.5+0.j 0. +0.j] [ True True False True True True False True True True False True True True False True] (0.4999999999999999+0j) False","title":"Measurement Incompatibility Testing"},{"location":"Incompatible_Measurement.html#measurement-incompatibility-testing","text":"# Make sure to load your IBM Q token before running the below block # Importing standard Qiskit libraries and configuring account from qiskit import QuantumCircuit , execute , Aer , IBMQ from qiskit.compiler import transpile , assemble from qiskit.tools.jupyter import * from qiskit.visualization import * from qiskit.providers.ibmq.managed import IBMQJobManager # Loading your IBM Q account(s) provider = IBMQ . load_account () import matplotlib.pyplot as plt import numpy as np # custom code import context from device_independent_test import incompatible_measurement ibmqfactory.load_account:WARNING:2020-06-25 13:41:58,859: Credentials are already in use. The existing account in the session will be replaced. def bb84_states (): # Alice's half of the circuit # creates 0,1,+,- qc = QuantumCircuit ( 4 ) qc . x ( 1 ) # create 1 qc . h ( 2 ) # create + qc . x ( 3 ) # create - qc . h ( 3 ) # ^ return qc def measure_circuit ( y ): # Bob's measurement circuit # measure in either pi/4 or 3pi/4 basis assert y == 0 or y == 1 , \"Bob's input should be 0 or 1\" qc = QuantumCircuit ( 4 ) theta = - 1.0 * ( np . pi / 4 + 0.5 * y * np . pi ) qc . u3 ( theta , 0 , 0 , range ( 0 , 4 )) #qc.u3(theta,0,0,1) #qc.u3(theta,0,0,2) #qc.u3(theta,0,0,3) qc . measure_all () return qc qc = bb84_states () + measure_circuit ( 0 ) qc . draw () \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 \u2591 \u250c\u2500\u2510 q_0: \u2524 U3(-pi/4,0,0) \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2591\u2500\u2524M\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 \u2514\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2518\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 \u2591 \u2514\u2565\u2518\u250c\u2500\u2510 q_1: \u2500\u2500\u2500\u2500\u2500\u2500\u2524 X \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2524 U3(-pi/4,0,0) \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2591\u2500\u2500\u256b\u2500\u2524M\u251c\u2500\u2500\u2500\u2500\u2500\u2500 \u251c\u2500\u2500\u2500\u2524 \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524 \u2591 \u2551 \u2514\u2565\u2518\u250c\u2500\u2510 q_2: \u2500\u2500\u2500\u2500\u2500\u2500\u2524 H \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2524 U3(-pi/4,0,0) \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2591\u2500\u2500\u256b\u2500\u2500\u256b\u2500\u2524M\u251c\u2500\u2500\u2500 \u251c\u2500\u2500\u2500\u2524 \u2514\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2518\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 \u2591 \u2551 \u2551 \u2514\u2565\u2518\u250c\u2500\u2510 q_3: \u2500\u2500\u2500\u2500\u2500\u2500\u2524 X \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524 H \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2524 U3(-pi/4,0,0) \u251c\u2500\u2591\u2500\u2500\u256b\u2500\u2500\u256b\u2500\u2500\u256b\u2500\u2524M\u251c \u2514\u2500\u2500\u2500\u2518 \u2514\u2500\u2500\u2500\u2518 \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518 \u2591 \u2551 \u2551 \u2551 \u2514\u2565\u2518 meas_0: \u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2569\u2550\u2550\u256c\u2550\u2550\u256c\u2550\u2550\u256c\u2550 \u2551 \u2551 \u2551 meas_1: \u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2569\u2550\u2550\u256c\u2550\u2550\u256c\u2550 \u2551 \u2551 meas_2: \u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2569\u2550\u2550\u256c\u2550 \u2551 meas_3: \u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2569\u2550 # OUTDATED CODE # SEE CELL BELOW FOR BATCH JOB from qiskit.tools.monitor import * def run_job ( qc ): # runs test on all inputs # run cicuits in one batch #job_manager = IBMQJobManager() #job_set = job_manager.run([qc_0, qc_1], backend=provider.get_backend('ibmq_qasm_simulator'), name='msrincom_test') #job_monitor(job_set) #job_set.error_message() job = execute ( qc , backend = provider . get_backend ( 'ibmq_qasm_simulator' ), shots = 1000 ) job_monitor ( job ) return job qc_0 = bb84_states () + measure_circuit ( 0 ) job = run_job ( qc_0 ) job . result () . get_counts ( qc_0 ) plot_histogram ( job . result () . get_counts ( qc_0 )) Job Status: job has successfully run from qiskit.tools.monitor import * def run_jobs ( qc ): # run cicuits in one batch job_manager = IBMQJobManager () job_set = job_manager . run ( qc , backend = provider . get_backend ( 'ibmq_qasm_simulator' ), name = 'msrincom_test' ) job_set . error_messages () return job_set qc_0 = bb84_states () + measure_circuit ( 0 ) qc_1 = bb84_states () + measure_circuit ( 1 ) managed_job = run_jobs ([ qc_0 , qc_1 ]) result_0 = managed_job . job ( 0 )[ 0 ] . result () result_1 = managed_job . job ( 1 )[ 0 ] . result () #managed_job.job(0)[0].error_message() result_0 . get_counts ( qc_0 ) {'1011': 85, '0000': 17, '0001': 2, '1001': 23, '1111': 20, '1100': 18, '1010': 524, '0010': 104, '0100': 4, '0111': 3, '1101': 4, '0110': 10, '1110': 94, '1000': 105, '0011': 11} qc_1 = bb84_states () + measure_circuit ( 1 ) job2 = run_job ( qc_1 ) job2 . result () . get_counts ( qc_1 ) plot_histogram ( job2 . result () . get_counts ( qc_1 )) Job Status: job has successfully run counts = job2 . result () . get_counts ( qc_1 ) print ( counts ) # 2x4 matrix for probabilities # row for x # column for y bins = ( 2 , 4 ) bins = np . zeros ( bins ) # iterate over dictionary for state in counts : for i in range ( 0 , 4 ): r = int ( state [ i ]) c = 3 - i bins [ r , c ] += counts [ state ] print ( bins ) # convert bins to probibilities probs = bins / 1000.0 print ( probs ) {'1011': 78, '0000': 11, '0001': 103, '1001': 523, '1111': 17, '1100': 14, '0101': 19, '1010': 16, '0111': 3, '1101': 103, '0110': 1, '1110': 5, '1000': 91, '0011': 16} [[138. 864. 838. 153.] [862. 136. 162. 847.]] [[0.138 0.864 0.838 0.153] [0.862 0.136 0.162 0.847]] from qiskit.quantum_info import Statevector qc = bb84_states () state = Statevector . from_instruction ( qc ) print ( state ) real_state = [ 0 , 0 , 0.5 + 0.j , 0 , 0 , 0 , 0.5 , 0 , 0 , 0 , - 0.5 , 0 , 0 , 0 , - 0.5 , 0 ] print ( state . data ) print ( state . data == real_state ) print ( state . data [ 2 ]) error = abs ( state . data - real_state ) epsilon = 1.0E-4 any ( x > epsilon for x in error ) Statevector([ 0. +0.j, 0. +0.j, 0.5+0.j, 0. +0.j, 0. +0.j, 0. +0.j, 0.5+0.j, 0. +0.j, 0. +0.j, 0. +0.j, -0.5+0.j, 0. +0.j, 0. +0.j, 0. +0.j, -0.5+0.j, 0. +0.j], dims=(2, 2, 2, 2)) [ 0. +0.j 0. +0.j 0.5+0.j 0. +0.j 0. +0.j 0. +0.j 0.5+0.j 0. +0.j 0. +0.j 0. +0.j -0.5+0.j 0. +0.j 0. +0.j 0. +0.j -0.5+0.j 0. +0.j] [ True True False True True True False True True True False True True True False True] (0.4999999999999999+0j) False","title":"Measurement Incompatibility Testing"},{"location":"Theory_for_Incompatible_Measurement_Test.html","text":"A Single-Qubit Bell Violation as a Device-Independent Test \u00b6 This notebook describe the quantum violation of a novel bell inequality bounding classical communication systems. The Bell violation does not require entanglement and is achieved by incompatible measurements and qubit superposition alone. Generally, a Bell violation describes non-classical measurement statistics which can only be achieved by a quantum system. That is, Alice and Bob cannot violate a Bell inequality using a classical system and shared randomness. The quantum-classical separation allows for a strong device independent test to be setup provided the following assumptions hold: Test Assumptions: \u00b6 Alice and Bob receive independent input drawn from uniform random distributions. Alice sends Bob no more than 1-bit or 1-qubit. If the assumptions are met, a single-qubit bell violation is sufficient to classify the bipartite communication system as a quantum communication system capable of superposition and incompatible measurements. In an ideal implementation where the communication channel is proven to be limited, Alice and Bob do not need to be trusted. If it is not possible to verify the channel capacity, then Alice or Bob must be trusted for the test to work. Note: Supporting Software \u00b6 The following Bell inequality and quantum violation were found using the open-source julia package, BellScenario.jl . This package is currently in an alpha version and is unfortunately experiencing a bug which prevents proper execution within a Jupyter notebook. The result is reported in the following cells. Test Setting \u00b6 We consider a single-qubit scenario where Alice and Bob each have a black-box with classical inputs and outputs. Alice is given an input, x\\in\\{0,1,2,3\\} x\\in\\{0,1,2,3\\} and encodes the value in a qubit, \\rho_x \\rho_x . The qubit is sent to Bob via some communication channel. Bob receives the qubit and performs a projective measurement based on the input y\\in\\{0,1\\} y\\in\\{0,1\\} . The outcome of the measurement, b\\in\\{0,1\\} b\\in\\{0,1\\} is output by Bob. This black-box scenario is characterized in a device-independent way by considering its set of conditional probabilities \\{p(b|xy)\\} \\{p(b|xy)\\} . The conditional probability distribution or behavior of a black-box device can be considered as a vector \\vec{p} \\vec{p} where each element corresponds to a different probability p(b|xy) p(b|xy) . The Classical Bound \u00b6 The classical set of probabilities \\mathcal{C} \\mathcal{C} is the convex hull of the deterministic black-box behaviors, \\mathcal{C} = \\text{conv}(\\vec{p}_D) \\mathcal{C} = \\text{conv}(\\vec{p}_D) . A behavior is deterministic if p(b|xy)\\in \\{0,1\\} p(b|xy)\\in \\{0,1\\} for all b b , x x , and y y . The deterministic behaviors of a black-box scenario are finite and therefore describe a convex polytope. A Bell inequality is a linear inequality that bounds the classical polytope for a black-box scenario. Given the inputs, outputs, and communication between Alice and Bob, the bell inequalities can be computed. The procedure is to first enumerate the deterministic behaviors, then use a polytope transformation algorithm to find the bounding inequalities. The vertices and facets used for this result are computed using the BellScenario.jl julia package. A significant Bell inequality for which there is a quantum violation is expressed, 6 \\geq \\Big(p(0|00) + p(1|10) + p(0|20) + p(1|30)\\Big) + \\Big(p(1|01) + p(0|11) + p(0|21) + p(1|31)\\Big). 6 \\geq \\Big(p(0|00) + p(1|10) + p(0|20) + p(1|30)\\Big) + \\Big(p(1|01) + p(0|11) + p(0|21) + p(1|31)\\Big). This inequality may be daunting, but it can be broken down by Bob's input y=0 y=0 (left) and y=1 y=1 (right). It is important to reiterate that Alice and Bob do not know each other's input. Alice's Best strategy is to use an encoding such as 0,2 \\rightarrow |0\\rangle 0,2 \\rightarrow |0\\rangle and 1,3 \\rightarrow |1\\rangle 1,3 \\rightarrow |1\\rangle , while Bob performs and identity decoding for y=0 y=0 and an inverted decoding for y=1 y=1 . Explicitly, the identity decoder is \\{|0\\rangle\\langle0|,|1\\rangle\\langle1|\\} \\{|0\\rangle\\langle0|,|1\\rangle\\langle1|\\} and the inverting decoder is \\{|0\\rangle\\langle1|,|1\\rangle\\langle0| \\} \\{|0\\rangle\\langle1|,|1\\rangle\\langle0| \\} . However, a closer look at the bell inequality reveals that when y=1 y=1 , a violation would require Bob to be able to invert only the received but only when Alice has input x\\in\\{0,1\\} x\\in\\{0,1\\} . Bob does not know Alice's inputs, so there is no way for Bob to condition a decoding strategy on Alice's input. As a result, classical communication limited systems cannot violate the bell inequality. In the case where Alice is able to share the input x x with Bob, a conditional decoding strategy could be applied and a violation would occur. This edge case is precisely why the communication channel must be proven to limited to to a single bit or qubit of information. Quantum Violation \u00b6 Quantum mechanics can violate the discussed Bell inequality using the following protocol. This protocol was computed using the BellScenario.jl julia package to optimize the quantum violation using semi-definite programming. Alice encodes the input x x into a BB84 qubit state |\\psi_x\\rangle |\\psi_x\\rangle where |\\psi_0\\rangle = |0\\rangle |\\psi_0\\rangle = |0\\rangle , |\\psi_1\\rangle =|1\\rangle |\\psi_1\\rangle =|1\\rangle , |\\psi_2\\rangle = |+\\rangle |\\psi_2\\rangle = |+\\rangle , |\\psi_3\\rangle = |-\\rangle |\\psi_3\\rangle = |-\\rangle . Bob measures with a projective measurement onto a basis rotated off the BB84 states by an angle \\theta=\\pi/4 \\theta=\\pi/4 . The measurement bases for each input y y are expressed \\begin{align} &|\\Pi_0^{y=0}\\rangle = \\cos(\\pi/8)|0\\rangle + \\sin(\\pi/8)|1\\rangle, \\quad |\\Pi_1^{y=0}\\rangle = \\sin(\\pi/8)|0\\rangle - \\cos(\\pi/8)|1\\rangle \\\\ &|\\Pi_0^{y=1}\\rangle = \\cos(3\\pi/8)|0\\rangle + \\sin(3\\pi/8)|1\\rangle, \\quad |\\Pi_1^{y=1}\\rangle = \\sin(3\\pi/8)|0\\rangle - \\cos(3\\pi/8)|1\\rangle \\\\ \\end{align} \\begin{align} &|\\Pi_0^{y=0}\\rangle = \\cos(\\pi/8)|0\\rangle + \\sin(\\pi/8)|1\\rangle, \\quad |\\Pi_1^{y=0}\\rangle = \\sin(\\pi/8)|0\\rangle - \\cos(\\pi/8)|1\\rangle \\\\ &|\\Pi_0^{y=1}\\rangle = \\cos(3\\pi/8)|0\\rangle + \\sin(3\\pi/8)|1\\rangle, \\quad |\\Pi_1^{y=1}\\rangle = \\sin(3\\pi/8)|0\\rangle - \\cos(3\\pi/8)|1\\rangle \\\\ \\end{align} Since the quantum states consist of |0/1\\rangle |0/1\\rangle and |+/-\\rangle |+/-\\rangle bases, they require superposition to construct. Likewise, the quantum measurements are incompatible because the two measurement sets align with rotated |0/1\\rangle |0/1\\rangle and |+/-\\rangle |+/-\\rangle bases and therefore do not commute. On Bloch sphere, the states and measurements lie within the x x - z z -plane and take the following orientation. The conditional probabilities of each outcome are computed through the inner product, p(b|xy) = |\\langle\\Pi_b^y|\\psi_x\\rangle|^2 = \\cos^2(\\phi/2) p(b|xy) = |\\langle\\Pi_b^y|\\psi_x\\rangle|^2 = \\cos^2(\\phi/2) , where \\phi \\phi is the angle of separation between |\\psi_x\\rangle |\\psi_x\\rangle , and |\\Pi_b^y\\rangle |\\Pi_b^y\\rangle on Bloch sphere. By the symmetry of the BB84 states \\phi \\phi can be one of two values \\pi/4 \\pi/4 or 3\\pi/4 3\\pi/4 , therefore, p(b|xy)\\in \\{\\cos^2(\\pi/8),\\cos^2(3\\pi/8)\\} p(b|xy)\\in \\{\\cos^2(\\pi/8),\\cos^2(3\\pi/8)\\} . Computing the conditional probabilities for the classical bound, it is found that each of the probabilities in the inequality take on the value p(b|xy) = \\cos^2(\\pi/8) p(b|xy) = \\cos^2(\\pi/8) . Summing up all of the conditional probabilities in the inequality, a violation is found, 8\\cos^2(\\pi/8) = 6.818 \\nleq 6. 8\\cos^2(\\pi/8) = 6.818 \\nleq 6. The protocol violates the classical bound by 13.6\\% 13.6\\% . The quantum violation occurs with a single qubit. There is no entanglement, only superposition and measurement incompatibility. Analyzing the Quantum Violation \u00b6 This analysis shows: 1. The quantum protocol violates and is optimal for the bb84 states. 2. Using compatible measurments with the BB84 states does not enable violation. 3. Using classical states with compatible or incompatible measurements does not enable violation. It can be concluded that superposition and measurement incompatibility are both required for a violation to occur in this protocol. % matplotlib inline import matplotlib.pyplot as plt import numpy as np import context from device_independent_test import incompatible_measurement # Setup # Alice's qubits states \u03c8 0 = [ 1 , 0 ] \u03c8 1 = [ 0 , 1 ] \u03c8 2 = [ 1 , 1 ] / np . sqrt ( 2 ) \u03c8 3 = [ 1 , - 1 ] / np . sqrt ( 2 ) # Quantum state Encodings \u03c8 _bb84 = [ \u03c8 0 , \u03c8 1 , \u03c8 2 , \u03c8 3 ] \u03c8 _classical = [ \u03c8 0 , \u03c8 1 , \u03c8 0 , \u03c8 1 ] # Bob's projective measurements \u03a0by \u03a0 00 = lambda \u03b8 : [ np . cos ( \u03b8 ), np . sin ( \u03b8 )] \u03a0 10 = lambda \u03b8 : [ np . sin ( \u03b8 ), - np . cos ( \u03b8 )] \u03a0 01 = lambda \u03b8 : [ np . cos ( \u03b8 + np . pi / 4 ), np . sin ( \u03b8 + np . pi / 4 )] \u03a0 11 = lambda \u03b8 : [ np . sin ( \u03b8 + np . pi / 4 ), - np . cos ( \u03b8 + np . pi / 4 )] # incompatible projective measurments y0_\u03a0 = [ \u03a0 00 , \u03a0 10 ] y1_\u03a0 = [ \u03a0 01 , \u03a0 11 ] # measurement compatible with y0_\u03a0 y1_cl_\u03a0 = [ \u03a0 11 , \u03a0 01 ] # Computing scores against the bell inequality # bb84 states with in/compatible measurements bb84_incompatible_scores = [] bb84_compatible_scores = [] # classical states with in/compatible measurements cl_compatible_scores = [] cl_incompatible_scores = [] classical_bound = [] # Measurement angle on a hilbert space \u03b8 _series = np . arange ( 0 , np . pi / 2 , np . pi / 2048 ) # computing the bell scores as the measurements are rotated about the y-axis. for \u03b8 in \u03b8 _series : # conditional probability matrices y0_probs = np . zeros (( 2 , 4 )) y0_cl_probs = np . zeros (( 2 , 4 )) y1_probs = np . zeros (( 2 , 4 )) y1_cl_incomp_probs = np . zeros (( 2 , 4 )) y1_comp_probs = np . zeros (( 2 , 4 )) y1_cl_comp_probs = np . zeros (( 2 , 4 )) for x in range ( 0 , 4 ): \u03c8 x_bb84 = \u03c8 _bb84 [ x ] \u03c8 x_cl = \u03c8 _classical [ x ] for b in range ( 0 , 2 ): # y=0 measurement \u03a0 b0 = y0_\u03a0 [ b ] y0_probs [ b , x ] = np . inner ( \u03a0 b0 ( \u03b8 ), \u03c8 x_bb84 ) ** 2 y0_cl_probs [ b , x ] = np . inner ( \u03a0 b0 ( \u03b8 ), \u03c8 x_cl ) ** 2 # y=1 incompatible measurement \u03a0 b1 = y1_\u03a0 [ b ] y1_probs [ b , x ] = np . inner ( \u03a0 b1 ( \u03b8 ), \u03c8 x_bb84 ) ** 2 y1_cl_incomp_probs [ b , x ] = np . inner ( \u03a0 b1 ( \u03b8 ), \u03c8 x_cl ) ** 2 # y=1 compatible measurement \u03a0 b1_comp = y1_cl_\u03a0 [ b ] y1_comp_probs [ b , x ] = np . inner ( \u03a0 b1_comp ( \u03b8 ), \u03c8 x_bb84 ) ** 2 y1_cl_comp_probs [ b , x ] = np . inner ( \u03a0 b1_comp ( \u03b8 ), \u03c8 x_cl ) ** 2 bb84_incompatible_scores . append ( incompatible_measurement . bell_score ( y0_probs , y1_probs )) bb84_compatible_scores . append ( incompatible_measurement . bell_score ( y0_probs , y0_probs )) cl_incompatible_scores . append ( incompatible_measurement . bell_score ( y0_cl_probs , y1_cl_incomp_probs )) cl_compatible_scores . append ( incompatible_measurement . bell_score ( y0_cl_probs , y1_cl_comp_probs )) classical_bound . append ( 6 ) Violation Occurs for BB84 States and Incompatible Measurements \u00b6 The discussed quantum protocol violates with the Max Quantum Violation of 6.818 6.818 . The Incompatible Measurements plot shows that if measurments are rotated in either direction, the violation decreases. This implies that the discussed protocol has been aligned in the optimal fashion. The Compatible Measurments plot shows that there is no rotation angle for which compatible measurements can violate the quantum bound. The conclusion is that superposition is necessary for this violation, but is not sufficient on its own. Measurment incompatiblity must also be applied. bb84_incomp_plt , = plt . plot ( \u03b8 _series , bb84_incompatible_scores , label = 'Incomp Measurment' , linestyle = '-.' ) cl_bound_plt , = plt . plot ( \u03b8 _series , classical_bound , label = 'Classical Bound' ) max_violation , = plt . plot ( np . pi / 8 , 6.828 , 'ro' , label = \"Max Quantum Violation\" ) bb84_comp_plt , = plt . plot ( \u03b8 _series , bb84_compatible_scores , label = \"Comp Measurement\" , linestyle = '--' ) plt . legend ( [ max_violation , bb84_incomp_plt , cl_bound_plt , bb84_comp_plt ], [ 'Max Quantum Violation' , 'Incompatible Measurements' , 'Classical Bound' , 'Compatible Measurements' ]) plt . xlabel ( \"Measurement Rotation Angle (radians)\" ) plt . ylabel ( \"Bell Score\" ) plt . title ( \"Quantum State Measurements vs. Angle\" ); No Violation Occurs for Classical States \u00b6 We now discuss the below plot for measurements on classical states used in this protocol. The Incompatible Measurements plot shows that if classical states are used, Bob cannot create a violation using incompatible mesurments. The Compatible Measurments plot shows that if classical states are used, Bob cannot create a violation using compatible measurements. The conclusion is that classical states cannot be used to violate with or without measurement incompatibility. # plot of quantum violation if classical measurements are used or classical states cl_incomp_plt , = plt . plot ( \u03b8 _series , cl_incompatible_scores , label = \"cl incomp\" , ) cl_bound_plt , = plt . plot ( \u03b8 _series , classical_bound , label = 'Classical Bound' ) cl_comp_plt , = plt . plot ( \u03b8 _series [:: 64 ], cl_compatible_scores [:: 64 ], 'rx' , label = \"cl comp\" ) plt . legend ( [ cl_bound_plt , cl_incomp_plt , cl_comp_plt ], [ 'Classical Bound' , 'Incompatible Measurements' , 'Compatible Measurements' ]) plt . xlabel ( \"Measurement Rotation Angle (radians)\" ) plt . ylabel ( \"Bell Score\" ) plt . title ( \"Classical State Measurements vs. Angle\" );","title":"Theory for Measurement Incompatibility Test"},{"location":"Theory_for_Incompatible_Measurement_Test.html#a-single-qubit-bell-violation-as-a-device-independent-test","text":"This notebook describe the quantum violation of a novel bell inequality bounding classical communication systems. The Bell violation does not require entanglement and is achieved by incompatible measurements and qubit superposition alone. Generally, a Bell violation describes non-classical measurement statistics which can only be achieved by a quantum system. That is, Alice and Bob cannot violate a Bell inequality using a classical system and shared randomness. The quantum-classical separation allows for a strong device independent test to be setup provided the following assumptions hold:","title":"A Single-Qubit Bell Violation as a Device-Independent Test"},{"location":"Theory_for_Incompatible_Measurement_Test.html#test-assumptions","text":"Alice and Bob receive independent input drawn from uniform random distributions. Alice sends Bob no more than 1-bit or 1-qubit. If the assumptions are met, a single-qubit bell violation is sufficient to classify the bipartite communication system as a quantum communication system capable of superposition and incompatible measurements. In an ideal implementation where the communication channel is proven to be limited, Alice and Bob do not need to be trusted. If it is not possible to verify the channel capacity, then Alice or Bob must be trusted for the test to work.","title":"Test Assumptions:"},{"location":"Theory_for_Incompatible_Measurement_Test.html#note-supporting-software","text":"The following Bell inequality and quantum violation were found using the open-source julia package, BellScenario.jl . This package is currently in an alpha version and is unfortunately experiencing a bug which prevents proper execution within a Jupyter notebook. The result is reported in the following cells.","title":"Note: Supporting Software"},{"location":"Theory_for_Incompatible_Measurement_Test.html#test-setting","text":"We consider a single-qubit scenario where Alice and Bob each have a black-box with classical inputs and outputs. Alice is given an input, x\\in\\{0,1,2,3\\} x\\in\\{0,1,2,3\\} and encodes the value in a qubit, \\rho_x \\rho_x . The qubit is sent to Bob via some communication channel. Bob receives the qubit and performs a projective measurement based on the input y\\in\\{0,1\\} y\\in\\{0,1\\} . The outcome of the measurement, b\\in\\{0,1\\} b\\in\\{0,1\\} is output by Bob. This black-box scenario is characterized in a device-independent way by considering its set of conditional probabilities \\{p(b|xy)\\} \\{p(b|xy)\\} . The conditional probability distribution or behavior of a black-box device can be considered as a vector \\vec{p} \\vec{p} where each element corresponds to a different probability p(b|xy) p(b|xy) .","title":"Test Setting"},{"location":"Theory_for_Incompatible_Measurement_Test.html#the-classical-bound","text":"The classical set of probabilities \\mathcal{C} \\mathcal{C} is the convex hull of the deterministic black-box behaviors, \\mathcal{C} = \\text{conv}(\\vec{p}_D) \\mathcal{C} = \\text{conv}(\\vec{p}_D) . A behavior is deterministic if p(b|xy)\\in \\{0,1\\} p(b|xy)\\in \\{0,1\\} for all b b , x x , and y y . The deterministic behaviors of a black-box scenario are finite and therefore describe a convex polytope. A Bell inequality is a linear inequality that bounds the classical polytope for a black-box scenario. Given the inputs, outputs, and communication between Alice and Bob, the bell inequalities can be computed. The procedure is to first enumerate the deterministic behaviors, then use a polytope transformation algorithm to find the bounding inequalities. The vertices and facets used for this result are computed using the BellScenario.jl julia package. A significant Bell inequality for which there is a quantum violation is expressed, 6 \\geq \\Big(p(0|00) + p(1|10) + p(0|20) + p(1|30)\\Big) + \\Big(p(1|01) + p(0|11) + p(0|21) + p(1|31)\\Big). 6 \\geq \\Big(p(0|00) + p(1|10) + p(0|20) + p(1|30)\\Big) + \\Big(p(1|01) + p(0|11) + p(0|21) + p(1|31)\\Big). This inequality may be daunting, but it can be broken down by Bob's input y=0 y=0 (left) and y=1 y=1 (right). It is important to reiterate that Alice and Bob do not know each other's input. Alice's Best strategy is to use an encoding such as 0,2 \\rightarrow |0\\rangle 0,2 \\rightarrow |0\\rangle and 1,3 \\rightarrow |1\\rangle 1,3 \\rightarrow |1\\rangle , while Bob performs and identity decoding for y=0 y=0 and an inverted decoding for y=1 y=1 . Explicitly, the identity decoder is \\{|0\\rangle\\langle0|,|1\\rangle\\langle1|\\} \\{|0\\rangle\\langle0|,|1\\rangle\\langle1|\\} and the inverting decoder is \\{|0\\rangle\\langle1|,|1\\rangle\\langle0| \\} \\{|0\\rangle\\langle1|,|1\\rangle\\langle0| \\} . However, a closer look at the bell inequality reveals that when y=1 y=1 , a violation would require Bob to be able to invert only the received but only when Alice has input x\\in\\{0,1\\} x\\in\\{0,1\\} . Bob does not know Alice's inputs, so there is no way for Bob to condition a decoding strategy on Alice's input. As a result, classical communication limited systems cannot violate the bell inequality. In the case where Alice is able to share the input x x with Bob, a conditional decoding strategy could be applied and a violation would occur. This edge case is precisely why the communication channel must be proven to limited to to a single bit or qubit of information.","title":"The Classical Bound"},{"location":"Theory_for_Incompatible_Measurement_Test.html#quantum-violation","text":"Quantum mechanics can violate the discussed Bell inequality using the following protocol. This protocol was computed using the BellScenario.jl julia package to optimize the quantum violation using semi-definite programming. Alice encodes the input x x into a BB84 qubit state |\\psi_x\\rangle |\\psi_x\\rangle where |\\psi_0\\rangle = |0\\rangle |\\psi_0\\rangle = |0\\rangle , |\\psi_1\\rangle =|1\\rangle |\\psi_1\\rangle =|1\\rangle , |\\psi_2\\rangle = |+\\rangle |\\psi_2\\rangle = |+\\rangle , |\\psi_3\\rangle = |-\\rangle |\\psi_3\\rangle = |-\\rangle . Bob measures with a projective measurement onto a basis rotated off the BB84 states by an angle \\theta=\\pi/4 \\theta=\\pi/4 . The measurement bases for each input y y are expressed \\begin{align} &|\\Pi_0^{y=0}\\rangle = \\cos(\\pi/8)|0\\rangle + \\sin(\\pi/8)|1\\rangle, \\quad |\\Pi_1^{y=0}\\rangle = \\sin(\\pi/8)|0\\rangle - \\cos(\\pi/8)|1\\rangle \\\\ &|\\Pi_0^{y=1}\\rangle = \\cos(3\\pi/8)|0\\rangle + \\sin(3\\pi/8)|1\\rangle, \\quad |\\Pi_1^{y=1}\\rangle = \\sin(3\\pi/8)|0\\rangle - \\cos(3\\pi/8)|1\\rangle \\\\ \\end{align} \\begin{align} &|\\Pi_0^{y=0}\\rangle = \\cos(\\pi/8)|0\\rangle + \\sin(\\pi/8)|1\\rangle, \\quad |\\Pi_1^{y=0}\\rangle = \\sin(\\pi/8)|0\\rangle - \\cos(\\pi/8)|1\\rangle \\\\ &|\\Pi_0^{y=1}\\rangle = \\cos(3\\pi/8)|0\\rangle + \\sin(3\\pi/8)|1\\rangle, \\quad |\\Pi_1^{y=1}\\rangle = \\sin(3\\pi/8)|0\\rangle - \\cos(3\\pi/8)|1\\rangle \\\\ \\end{align} Since the quantum states consist of |0/1\\rangle |0/1\\rangle and |+/-\\rangle |+/-\\rangle bases, they require superposition to construct. Likewise, the quantum measurements are incompatible because the two measurement sets align with rotated |0/1\\rangle |0/1\\rangle and |+/-\\rangle |+/-\\rangle bases and therefore do not commute. On Bloch sphere, the states and measurements lie within the x x - z z -plane and take the following orientation. The conditional probabilities of each outcome are computed through the inner product, p(b|xy) = |\\langle\\Pi_b^y|\\psi_x\\rangle|^2 = \\cos^2(\\phi/2) p(b|xy) = |\\langle\\Pi_b^y|\\psi_x\\rangle|^2 = \\cos^2(\\phi/2) , where \\phi \\phi is the angle of separation between |\\psi_x\\rangle |\\psi_x\\rangle , and |\\Pi_b^y\\rangle |\\Pi_b^y\\rangle on Bloch sphere. By the symmetry of the BB84 states \\phi \\phi can be one of two values \\pi/4 \\pi/4 or 3\\pi/4 3\\pi/4 , therefore, p(b|xy)\\in \\{\\cos^2(\\pi/8),\\cos^2(3\\pi/8)\\} p(b|xy)\\in \\{\\cos^2(\\pi/8),\\cos^2(3\\pi/8)\\} . Computing the conditional probabilities for the classical bound, it is found that each of the probabilities in the inequality take on the value p(b|xy) = \\cos^2(\\pi/8) p(b|xy) = \\cos^2(\\pi/8) . Summing up all of the conditional probabilities in the inequality, a violation is found, 8\\cos^2(\\pi/8) = 6.818 \\nleq 6. 8\\cos^2(\\pi/8) = 6.818 \\nleq 6. The protocol violates the classical bound by 13.6\\% 13.6\\% . The quantum violation occurs with a single qubit. There is no entanglement, only superposition and measurement incompatibility.","title":"Quantum Violation"},{"location":"Theory_for_Incompatible_Measurement_Test.html#analyzing-the-quantum-violation","text":"This analysis shows: 1. The quantum protocol violates and is optimal for the bb84 states. 2. Using compatible measurments with the BB84 states does not enable violation. 3. Using classical states with compatible or incompatible measurements does not enable violation. It can be concluded that superposition and measurement incompatibility are both required for a violation to occur in this protocol. % matplotlib inline import matplotlib.pyplot as plt import numpy as np import context from device_independent_test import incompatible_measurement # Setup # Alice's qubits states \u03c8 0 = [ 1 , 0 ] \u03c8 1 = [ 0 , 1 ] \u03c8 2 = [ 1 , 1 ] / np . sqrt ( 2 ) \u03c8 3 = [ 1 , - 1 ] / np . sqrt ( 2 ) # Quantum state Encodings \u03c8 _bb84 = [ \u03c8 0 , \u03c8 1 , \u03c8 2 , \u03c8 3 ] \u03c8 _classical = [ \u03c8 0 , \u03c8 1 , \u03c8 0 , \u03c8 1 ] # Bob's projective measurements \u03a0by \u03a0 00 = lambda \u03b8 : [ np . cos ( \u03b8 ), np . sin ( \u03b8 )] \u03a0 10 = lambda \u03b8 : [ np . sin ( \u03b8 ), - np . cos ( \u03b8 )] \u03a0 01 = lambda \u03b8 : [ np . cos ( \u03b8 + np . pi / 4 ), np . sin ( \u03b8 + np . pi / 4 )] \u03a0 11 = lambda \u03b8 : [ np . sin ( \u03b8 + np . pi / 4 ), - np . cos ( \u03b8 + np . pi / 4 )] # incompatible projective measurments y0_\u03a0 = [ \u03a0 00 , \u03a0 10 ] y1_\u03a0 = [ \u03a0 01 , \u03a0 11 ] # measurement compatible with y0_\u03a0 y1_cl_\u03a0 = [ \u03a0 11 , \u03a0 01 ] # Computing scores against the bell inequality # bb84 states with in/compatible measurements bb84_incompatible_scores = [] bb84_compatible_scores = [] # classical states with in/compatible measurements cl_compatible_scores = [] cl_incompatible_scores = [] classical_bound = [] # Measurement angle on a hilbert space \u03b8 _series = np . arange ( 0 , np . pi / 2 , np . pi / 2048 ) # computing the bell scores as the measurements are rotated about the y-axis. for \u03b8 in \u03b8 _series : # conditional probability matrices y0_probs = np . zeros (( 2 , 4 )) y0_cl_probs = np . zeros (( 2 , 4 )) y1_probs = np . zeros (( 2 , 4 )) y1_cl_incomp_probs = np . zeros (( 2 , 4 )) y1_comp_probs = np . zeros (( 2 , 4 )) y1_cl_comp_probs = np . zeros (( 2 , 4 )) for x in range ( 0 , 4 ): \u03c8 x_bb84 = \u03c8 _bb84 [ x ] \u03c8 x_cl = \u03c8 _classical [ x ] for b in range ( 0 , 2 ): # y=0 measurement \u03a0 b0 = y0_\u03a0 [ b ] y0_probs [ b , x ] = np . inner ( \u03a0 b0 ( \u03b8 ), \u03c8 x_bb84 ) ** 2 y0_cl_probs [ b , x ] = np . inner ( \u03a0 b0 ( \u03b8 ), \u03c8 x_cl ) ** 2 # y=1 incompatible measurement \u03a0 b1 = y1_\u03a0 [ b ] y1_probs [ b , x ] = np . inner ( \u03a0 b1 ( \u03b8 ), \u03c8 x_bb84 ) ** 2 y1_cl_incomp_probs [ b , x ] = np . inner ( \u03a0 b1 ( \u03b8 ), \u03c8 x_cl ) ** 2 # y=1 compatible measurement \u03a0 b1_comp = y1_cl_\u03a0 [ b ] y1_comp_probs [ b , x ] = np . inner ( \u03a0 b1_comp ( \u03b8 ), \u03c8 x_bb84 ) ** 2 y1_cl_comp_probs [ b , x ] = np . inner ( \u03a0 b1_comp ( \u03b8 ), \u03c8 x_cl ) ** 2 bb84_incompatible_scores . append ( incompatible_measurement . bell_score ( y0_probs , y1_probs )) bb84_compatible_scores . append ( incompatible_measurement . bell_score ( y0_probs , y0_probs )) cl_incompatible_scores . append ( incompatible_measurement . bell_score ( y0_cl_probs , y1_cl_incomp_probs )) cl_compatible_scores . append ( incompatible_measurement . bell_score ( y0_cl_probs , y1_cl_comp_probs )) classical_bound . append ( 6 )","title":"Analyzing the Quantum Violation"},{"location":"Theory_for_Incompatible_Measurement_Test.html#violation-occurs-for-bb84-states-and-incompatible-measurements","text":"The discussed quantum protocol violates with the Max Quantum Violation of 6.818 6.818 . The Incompatible Measurements plot shows that if measurments are rotated in either direction, the violation decreases. This implies that the discussed protocol has been aligned in the optimal fashion. The Compatible Measurments plot shows that there is no rotation angle for which compatible measurements can violate the quantum bound. The conclusion is that superposition is necessary for this violation, but is not sufficient on its own. Measurment incompatiblity must also be applied. bb84_incomp_plt , = plt . plot ( \u03b8 _series , bb84_incompatible_scores , label = 'Incomp Measurment' , linestyle = '-.' ) cl_bound_plt , = plt . plot ( \u03b8 _series , classical_bound , label = 'Classical Bound' ) max_violation , = plt . plot ( np . pi / 8 , 6.828 , 'ro' , label = \"Max Quantum Violation\" ) bb84_comp_plt , = plt . plot ( \u03b8 _series , bb84_compatible_scores , label = \"Comp Measurement\" , linestyle = '--' ) plt . legend ( [ max_violation , bb84_incomp_plt , cl_bound_plt , bb84_comp_plt ], [ 'Max Quantum Violation' , 'Incompatible Measurements' , 'Classical Bound' , 'Compatible Measurements' ]) plt . xlabel ( \"Measurement Rotation Angle (radians)\" ) plt . ylabel ( \"Bell Score\" ) plt . title ( \"Quantum State Measurements vs. Angle\" );","title":"Violation Occurs for BB84 States and Incompatible Measurements"},{"location":"Theory_for_Incompatible_Measurement_Test.html#no-violation-occurs-for-classical-states","text":"We now discuss the below plot for measurements on classical states used in this protocol. The Incompatible Measurements plot shows that if classical states are used, Bob cannot create a violation using incompatible mesurments. The Compatible Measurments plot shows that if classical states are used, Bob cannot create a violation using compatible measurements. The conclusion is that classical states cannot be used to violate with or without measurement incompatibility. # plot of quantum violation if classical measurements are used or classical states cl_incomp_plt , = plt . plot ( \u03b8 _series , cl_incompatible_scores , label = \"cl incomp\" , ) cl_bound_plt , = plt . plot ( \u03b8 _series , classical_bound , label = 'Classical Bound' ) cl_comp_plt , = plt . plot ( \u03b8 _series [:: 64 ], cl_compatible_scores [:: 64 ], 'rx' , label = \"cl comp\" ) plt . legend ( [ cl_bound_plt , cl_incomp_plt , cl_comp_plt ], [ 'Classical Bound' , 'Incompatible Measurements' , 'Compatible Measurements' ]) plt . xlabel ( \"Measurement Rotation Angle (radians)\" ) plt . ylabel ( \"Bell Score\" ) plt . title ( \"Classical State Measurements vs. Angle\" );","title":"No Violation Occurs for Classical States"},{"location":"example.html","text":"% matplotlib inline # Importing standard Qiskit libraries and configuring account from qiskit import QuantumCircuit , execute , Aer , IBMQ from qiskit.compiler import transpile , assemble from qiskit.tools.jupyter import * from qiskit.visualization import * # Loading your IBM Q account(s) provider = IBMQ . load_account () import matplotlib.pyplot as plt import numpy as np # custom code import context from device_independent_test import example example . hello () example . add_two ( - 3 ) hello -1 x_series = np . arange ( - 10 , 10 , 0.1 ) y_series = map ( example . parabola , x_series ) plt . plot ( list ( x_series ), list ( y_series )) plt . xlabel ( \"x\" ) plt . ylabel ( \"y\" ) plt . title ( \"y = x^2\" ); prepare_circuit = example . prepare_01_circuit () prepare_circuit . draw () q_0: \u2500\u2500\u2500\u2500\u2500 \u250c\u2500\u2500\u2500\u2510 q_1: \u2524 X \u251c \u2514\u2500\u2500\u2500\u2518 from qiskit.quantum_info import Statevector statevector = Statevector . from_instruction ( prepare_circuit ) print ( statevector . data ) [0.+0.j 0.+0.j 1.+0.j 0.+0.j] measure_circuit = example . measure_circuit ( 2 ) measure_circuit . draw () \u2591 \u250c\u2500\u2510 q_0: \u2500\u2591\u2500\u2524M\u251c\u2500\u2500\u2500 \u2591 \u2514\u2565\u2518\u250c\u2500\u2510 q_1: \u2500\u2591\u2500\u2500\u256b\u2500\u2524M\u251c \u2591 \u2551 \u2514\u2565\u2518 meas_0: \u2550\u2550\u2550\u2550\u2569\u2550\u2550\u256c\u2550 \u2551 meas_1: \u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2569\u2550 prepare_measure_circuit = prepare_circuit + measure_circuit prepare_measure_circuit . draw () \u2591 \u250c\u2500\u2510 q_0: \u2500\u2500\u2500\u2500\u2500\u2500\u2591\u2500\u2524M\u251c\u2500\u2500\u2500 \u250c\u2500\u2500\u2500\u2510 \u2591 \u2514\u2565\u2518\u250c\u2500\u2510 q_1: \u2524 X \u251c\u2500\u2591\u2500\u2500\u256b\u2500\u2524M\u251c \u2514\u2500\u2500\u2500\u2518 \u2591 \u2551 \u2514\u2565\u2518 meas_0: \u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2569\u2550\u2550\u256c\u2550 \u2551 meas_1: \u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2569\u2550 provider . backends () [<IBMQSimulator('ibmq_qasm_simulator') from IBMQ(hub='ibm-q', group='open', project='main')>, <IBMQBackend('ibmqx2') from IBMQ(hub='ibm-q', group='open', project='main')>, <IBMQBackend('ibmq_16_melbourne') from IBMQ(hub='ibm-q', group='open', project='main')>, <IBMQBackend('ibmq_vigo') from IBMQ(hub='ibm-q', group='open', project='main')>, <IBMQBackend('ibmq_ourense') from IBMQ(hub='ibm-q', group='open', project='main')>, <IBMQBackend('ibmq_london') from IBMQ(hub='ibm-q', group='open', project='main')>, <IBMQBackend('ibmq_burlington') from IBMQ(hub='ibm-q', group='open', project='main')>, <IBMQBackend('ibmq_essex') from IBMQ(hub='ibm-q', group='open', project='main')>, <IBMQBackend('ibmq_armonk') from IBMQ(hub='ibm-q', group='open', project='main')>, <IBMQBackend('ibmq_rome') from IBMQ(hub='ibm-q', group='open', project='main')>] quantum_system = provider . get_backend ( \"ibmq_qasm_simulator\" ) job = execute ( prepare_measure_circuit , backend = quantum_system , shots = 1000 ) from qiskit.tools.monitor import * job_monitor ( job ) Job Status: job has successfully run counts = job . result () . get_counts ( prepare_measure_circuit ) plot_histogram ( counts )","title":"Example"}]}